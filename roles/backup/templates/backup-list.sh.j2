#!/bin/bash
# Backup Listing and Management Script
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

# Configuration
BACKUP_LOCAL_DIR="{{ backup_local_dir }}"
BACKUP_BASE_DIR="{{ backup_base_dir }}"
CHECKPOINT_DIR="$BACKUP_LOCAL_DIR/checkpoints"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

show_usage() {
    cat << EOF
Usage: backup-list [OPTIONS]

OPTIONS:
    --backups              List regular backups (default)
    --checkpoints          List bootstrap checkpoints
    --all                  List both backups and checkpoints
    --external             Include external drive backups
    --details              Show detailed information
    --size                 Show backup sizes
    --json                 Output in JSON format
    --recent N             Show only N most recent items (default: 10)
    --filter PATTERN       Filter by name pattern
    --sort TYPE            Sort by: name, date, size (default: date)
    --help                 Show this help message

EXAMPLES:
    backup-list                              # List recent backups
    backup-list --checkpoints               # List bootstrap checkpoints
    backup-list --all --details             # Detailed view of everything
    backup-list --external --size           # Include external backups with sizes
    backup-list --filter "pre-setup"        # Filter by pattern
    backup-list --recent 5 --sort size      # 5 largest backups
    backup-list --json                      # JSON output for scripts
EOF
}

format_size() {
    local size_bytes="$1"
    
    if [ "$size_bytes" -eq 0 ]; then
        echo "0B"
    elif [ "$size_bytes" -lt 1024 ]; then
        echo "${size_bytes}B"
    elif [ "$size_bytes" -lt 1048576 ]; then
        echo "$(( size_bytes / 1024 ))KB"
    elif [ "$size_bytes" -lt 1073741824 ]; then
        echo "$(( size_bytes / 1048576 ))MB"
    else
        echo "$(( size_bytes / 1073741824 ))GB"
    fi
}

get_backup_size() {
    local backup_path="$1"
    
    if [ -d "$backup_path" ]; then
        du -sk "$backup_path" 2>/dev/null | cut -f1 || echo "0"
    else
        echo "0"
    fi
}

get_backup_info() {
    local backup_path="$1"
    local show_size="$2"
    
    local backup_name=$(basename "$backup_path")
    local backup_date=""
    local backup_size=""
    local backup_type=""
    local description=""
    local external_path=""
    
    # Get modification date
    if [ -d "$backup_path" ]; then
        backup_date=$(date -r "$backup_path" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "Unknown")
    fi
    
    # Get size if requested
    if [ "$show_size" = "true" ]; then
        local size_kb=$(get_backup_size "$backup_path")
        backup_size=$(format_size $((size_kb * 1024)))
    fi
    
    # Determine backup type and get metadata
    if [[ "$backup_path" =~ checkpoints ]]; then
        backup_type="checkpoint"
        if [ -f "$backup_path/metadata/checkpoint.json" ]; then
            description=$(grep '"description"' "$backup_path/metadata/checkpoint.json" 2>/dev/null | cut -d'"' -f4 || echo "")
        fi
    else
        backup_type="backup"
        if [ -f "$backup_path/metadata/external_path" ]; then
            external_path=$(cat "$backup_path/metadata/external_path")
        fi
    fi
    
    # Output format: name|date|size|type|description|external_path
    echo "${backup_name}|${backup_date}|${backup_size}|${backup_type}|${description}|${external_path}"
}

list_backups() {
    local include_external="$1"
    local pattern_filter="$2"
    
    local backup_paths=()
    
    # Collect local backups
    if [ -d "$BACKUP_LOCAL_DIR" ]; then
        while IFS= read -r -d '' backup; do
            local name=$(basename "$backup")
            if [[ "$name" =~ _[0-9]{8}_[0-9]{6}$ ]]; then
                if [ -z "$pattern_filter" ] || [[ "$name" =~ $pattern_filter ]]; then
                    backup_paths+=("$backup")
                fi
            fi
        done < <(find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" -print0 2>/dev/null || true)
    fi
    
    # Collect external backups if requested
    if [ "$include_external" = "true" ] && [ -d "$BACKUP_BASE_DIR" ]; then
        while IFS= read -r -d '' backup; do
            local name=$(basename "$backup")
            if [[ "$name" =~ _[0-9]{8}_[0-9]{6}$ ]]; then
                if [ -z "$pattern_filter" ] || [[ "$name" =~ $pattern_filter ]]; then
                    # Mark as external
                    backup_paths+=("${backup}|external")
                fi
            fi
        done < <(find "$BACKUP_BASE_DIR" -maxdepth 1 -type d -name "*_*" -print0 2>/dev/null || true)
    fi
    
    printf '%s\n' "${backup_paths[@]}"
}

list_checkpoints() {
    local pattern_filter="$1"
    
    local checkpoint_paths=()
    
    if [ -d "$CHECKPOINT_DIR" ]; then
        while IFS= read -r -d '' checkpoint; do
            local name=$(basename "$checkpoint")
            if [[ "$name" =~ _[0-9]{8}_[0-9]{6}$ ]]; then
                if [ -z "$pattern_filter" ] || [[ "$name" =~ $pattern_filter ]]; then
                    checkpoint_paths+=("$checkpoint")
                fi
            fi
        done < <(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*_*" -print0 2>/dev/null || true)
    fi
    
    printf '%s\n' "${checkpoint_paths[@]}"
}

sort_items() {
    local sort_type="$1"
    local show_size="$2"
    
    case "$sort_type" in
        name)
            sort -t'|' -k1,1
            ;;
        date)
            sort -t'|' -k2,2r
            ;;
        size)
            if [ "$show_size" = "true" ]; then
                # Sort by size (convert back to bytes for proper numeric sort)
                while IFS='|' read -r name date size type desc ext; do
                    local size_bytes=0
                    if [[ "$size" =~ ([0-9]+)KB ]]; then
                        size_bytes=$((${BASH_REMATCH[1]} * 1024))
                    elif [[ "$size" =~ ([0-9]+)MB ]]; then
                        size_bytes=$((${BASH_REMATCH[1]} * 1048576))
                    elif [[ "$size" =~ ([0-9]+)GB ]]; then
                        size_bytes=$((${BASH_REMATCH[1]} * 1073741824))
                    elif [[ "$size" =~ ([0-9]+)B ]]; then
                        size_bytes=${BASH_REMATCH[1]}
                    fi
                    printf "%010d|%s|%s|%s|%s|%s|%s\n" "$size_bytes" "$name" "$date" "$size" "$type" "$desc" "$ext"
                done | sort -t'|' -k1,1nr | cut -d'|' -f2-
            else
                # Fallback to date sort if size not available
                sort -t'|' -k2,2r
            fi
            ;;
        *)
            sort -t'|' -k2,2r  # Default to date
            ;;
    esac
}

display_table() {
    local show_details="$1"
    local show_size="$2"
    local json_output="$3"
    local recent_limit="$4"
    
    local count=0
    local json_items=()
    
    if [ "$json_output" = "true" ]; then
        echo "{"
        echo '  "backups": ['
    else
        # Print header
        if [ "$show_size" = "true" ]; then
            printf "${BOLD}%-30s %-19s %-8s %-10s %s${NC}\n" "NAME" "DATE" "SIZE" "TYPE" "DESCRIPTION"
        else
            printf "${BOLD}%-30s %-19s %-10s %s${NC}\n" "NAME" "DATE" "TYPE" "DESCRIPTION"
        fi
        printf "${BOLD}%s${NC}\n" "$(printf '=%.0s' {1..80})"
    fi
    
    while IFS='|' read -r name date size type description external_path; do
        if [ "$recent_limit" -gt 0 ] && [ "$count" -ge "$recent_limit" ]; then
            break
        fi
        
        if [ "$json_output" = "true" ]; then
            [ "$count" -gt 0 ] && echo ","
            echo "    {"
            echo "      \"name\": \"$name\","
            echo "      \"date\": \"$date\","
            echo "      \"type\": \"$type\""
            [ -n "$size" ] && echo "      \"size\": \"$size\","
            [ -n "$description" ] && echo "      \"description\": \"$description\","
            [ -n "$external_path" ] && echo "      \"external_path\": \"$external_path\","
            echo "    }"
        else
            # Determine color based on type
            local color=""
            case "$type" in
                checkpoint) color="$CYAN" ;;
                backup) color="$GREEN" ;;
                *) color="$NC" ;;
            esac
            
            # Format name with external indicator
            local display_name="$name"
            if [[ "$external_path" == *"external"* ]] || [ -n "$external_path" ]; then
                display_name="${name} ${YELLOW}[ext]${NC}"
            fi
            
            # Display row
            if [ "$show_size" = "true" ]; then
                printf "${color}%-30s${NC} %-19s %-8s %-10s %s\n" \
                    "$display_name" "$date" "$size" "$type" "$description"
            else
                printf "${color}%-30s${NC} %-19s %-10s %s\n" \
                    "$display_name" "$date" "$type" "$description"
            fi
            
            # Show details if requested
            if [ "$show_details" = "true" ]; then
                if [ -n "$external_path" ] && [[ "$external_path" != *"external"* ]]; then
                    printf "  ${BLUE}External:${NC} %s\n" "$external_path"
                fi
                
                # Show additional metadata for checkpoints
                if [ "$type" = "checkpoint" ]; then
                    local checkpoint_path=""
                    if [[ "$external_path" == *"external"* ]]; then
                        checkpoint_path=$(echo "$external_path" | sed 's/|external//')
                    else
                        checkpoint_path="$CHECKPOINT_DIR/$name"
                    fi
                    
                    if [ -f "$checkpoint_path/metadata/checkpoint.json" ]; then
                        local phase=$(grep '"bootstrap_phase"' "$checkpoint_path/metadata/checkpoint.json" 2>/dev/null | cut -d'"' -f4 || echo "")
                        local hostname=$(grep '"hostname"' "$checkpoint_path/metadata/checkpoint.json" 2>/dev/null | cut -d'"' -f4 || echo "")
                        [ -n "$phase" ] && [ "$phase" != "unknown" ] && printf "  ${BLUE}Phase:${NC} %s\n" "$phase"
                        [ -n "$hostname" ] && printf "  ${BLUE}Host:${NC} %s\n" "$hostname"
                    fi
                fi
                echo
            fi
        fi
        
        ((count++))
    done
    
    if [ "$json_output" = "true" ]; then
        echo
        echo "  ],"
        echo "  \"total_count\": $count"
        echo "}"
    else
        echo
        printf "${BLUE}Total: %d items${NC}\n" "$count"
        
        # Show storage usage summary
        if [ "$show_size" = "true" ]; then
            local total_local_kb=0
            local total_external_kb=0
            
            if [ -d "$BACKUP_LOCAL_DIR" ]; then
                total_local_kb=$(du -sk "$BACKUP_LOCAL_DIR" 2>/dev/null | cut -f1 || echo "0")
            fi
            
            if [ -d "$BACKUP_BASE_DIR" ]; then
                total_external_kb=$(du -sk "$BACKUP_BASE_DIR" 2>/dev/null | cut -f1 || echo "0")
            fi
            
            printf "${BLUE}Storage: Local %s" "$(format_size $((total_local_kb * 1024)))"
            if [ "$total_external_kb" -gt 0 ]; then
                printf ", External %s" "$(format_size $((total_external_kb * 1024)))"
            fi
            printf "${NC}\n"
        fi
    fi
}

show_summary() {
    local include_external="$1"
    
    local backup_count=0
    local checkpoint_count=0
    local external_backup_count=0
    
    # Count local backups
    if [ -d "$BACKUP_LOCAL_DIR" ]; then
        backup_count=$(find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" | wc -l)
    fi
    
    # Count checkpoints
    if [ -d "$CHECKPOINT_DIR" ]; then
        checkpoint_count=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*_*" | wc -l)
    fi
    
    # Count external backups
    if [ "$include_external" = "true" ] && [ -d "$BACKUP_BASE_DIR" ]; then
        external_backup_count=$(find "$BACKUP_BASE_DIR" -maxdepth 1 -type d -name "*_*" | wc -l)
    fi
    
    echo -e "${BOLD}Backup Summary${NC}"
    echo "=============="
    printf "Local backups:     %d\n" "$backup_count"
    printf "Checkpoints:       %d\n" "$checkpoint_count"
    if [ "$include_external" = "true" ]; then
        printf "External backups:  %d\n" "$external_backup_count"
    fi
    echo
    
    # Show latest items
    if [ "$backup_count" -gt 0 ] || [ "$checkpoint_count" -gt 0 ]; then
        echo "Recent items:"
        
        # Latest backup
        local latest_backup=$(find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" 2>/dev/null | sort -r | head -1)
        if [ -n "$latest_backup" ]; then
            local backup_date=$(date -r "$latest_backup" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "Unknown")
            printf "  ${GREEN}Latest backup:${NC}     %s (%s)\n" "$(basename "$latest_backup")" "$backup_date"
        fi
        
        # Latest checkpoint
        local latest_checkpoint=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*_*" 2>/dev/null | sort -r | head -1)
        if [ -n "$latest_checkpoint" ]; then
            local checkpoint_date=$(date -r "$latest_checkpoint" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "Unknown")
            printf "  ${CYAN}Latest checkpoint:${NC} %s (%s)\n" "$(basename "$latest_checkpoint")" "$checkpoint_date"
        fi
    fi
}

# Main execution
main() {
    local show_backups=true
    local show_checkpoints=false
    local include_external=false
    local show_details=false
    local show_size=false
    local json_output=false
    local recent_limit=10
    local pattern_filter=""
    local sort_type="date"
    local show_summary_only=false
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --backups)
                show_backups=true
                show_checkpoints=false
                shift
                ;;
            --checkpoints)
                show_backups=false
                show_checkpoints=true
                shift
                ;;
            --all)
                show_backups=true
                show_checkpoints=true
                shift
                ;;
            --external)
                include_external=true
                shift
                ;;
            --details)
                show_details=true
                shift
                ;;
            --size)
                show_size=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            --recent)
                recent_limit="$2"
                shift 2
                ;;
            --filter)
                pattern_filter="$2"
                shift 2
                ;;
            --sort)
                sort_type="$2"
                shift 2
                ;;
            --summary)
                show_summary_only=true
                shift
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                show_usage
                exit 1
                ;;
        esac
    done
    
    # Show summary and exit if requested
    if [ "$show_summary_only" = "true" ]; then
        show_summary "$include_external"
        exit 0
    fi
    
    # Collect and process items
    local all_items=()
    
    if [ "$show_backups" = "true" ]; then
        while IFS= read -r backup_path; do
            if [ -n "$backup_path" ]; then
                local info=$(get_backup_info "$backup_path" "$show_size")
                all_items+=("$info")
            fi
        done < <(list_backups "$include_external" "$pattern_filter")
    fi
    
    if [ "$show_checkpoints" = "true" ]; then
        while IFS= read -r checkpoint_path; do
            if [ -n "$checkpoint_path" ]; then
                local info=$(get_backup_info "$checkpoint_path" "$show_size")
                all_items+=("$info")
            fi
        done < <(list_checkpoints "$pattern_filter")
    fi
    
    # Sort and display
    if [ "{% raw %}${#all_items[@]}{% endraw %}" -eq 0 ]; then
        if [ "$json_output" = "true" ]; then
            echo '{"backups": [], "total_count": 0}'
        else
            echo "No backups or checkpoints found."
        fi
        exit 0
    fi
    
    printf '%s\n' "${all_items[@]}" | \
        sort_items "$sort_type" "$show_size" | \
        display_table "$show_details" "$show_size" "$json_output" "$recent_limit"
}

# Run main function
main "$@"