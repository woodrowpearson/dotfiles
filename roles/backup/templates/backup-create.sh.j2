#!/bin/bash
# Comprehensive Backup Creation Script
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

# Configuration
BACKUP_LOCAL_DIR="{{ backup_local_dir }}"
BACKUP_BASE_DIR="{{ backup_base_dir }}"
ENCRYPTION_ENABLED={{ backup_encryption.enabled | lower }}
TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
LOGFILE="$BACKUP_LOCAL_DIR/logs/backup_$TIMESTAMP.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOGFILE"
}

success() {
    echo -e "${GREEN}✅ $1${NC}" | tee -a "$LOGFILE"
}

warning() {
    echo -e "${YELLOW}⚠️  $1${NC}" | tee -a "$LOGFILE"
}

error() {
    echo -e "${RED}❌ $1${NC}" | tee -a "$LOGFILE"
    exit 1
}

show_usage() {
    cat << EOF
Usage: backup-create [OPTIONS]

OPTIONS:
    --full                  Complete backup (configs + system snapshot)
    --config-only          Configuration files only
    --with-projects         Include development projects
    --phase PHASE          Specify backup phase (pre-setup, post-setup)
    --name NAME            Custom backup name
    --encrypt              Force encryption for this backup
    --no-encrypt           Skip encryption for this backup
    --quiet                Minimal output
    --initialize           Initialize backup system
    --help                 Show this help message

EXAMPLES:
    backup-create --full                           # Complete backup
    backup-create --config-only                    # Quick config backup
    backup-create --phase pre-setup --full         # Pre-bootstrap backup
    backup-create --name "before-vscode-update"    # Named checkpoint
EOF
}

check_dependencies() {
    local deps=("rsync" "gpg")
    {% if backup_components.applications %}
    deps+=("mackup")
    {% endif %}
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            error "Required dependency '$dep' not found. Run: brew install $dep"
        fi
    done
}

check_backup_drive() {
    if [ ! -d "$(dirname "$BACKUP_BASE_DIR")" ]; then
        warning "External backup drive not connected. Using local backup only."
        return 1
    fi
    return 0
}

create_backup_structure() {
    local backup_name="$1"
    local backup_dir="$BACKUP_LOCAL_DIR/$backup_name"
    
    mkdir -p "$backup_dir"/{configs,security,development,system,metadata}
    echo "$TIMESTAMP" > "$backup_dir/metadata/timestamp"
    echo "$(uname -a)" > "$backup_dir/metadata/system_info"
    echo "$(sw_vers)" > "$backup_dir/metadata/macos_version"
    
    if check_backup_drive; then
        local external_backup_dir="$BACKUP_BASE_DIR/$backup_name"
        mkdir -p "$external_backup_dir"
        echo "$external_backup_dir" > "$backup_dir/metadata/external_path"
    fi
    
    echo "$backup_dir"
}

backup_application_configs() {
    local backup_dir="$1"
    log "Backing up application configurations..."
    
    {% if backup_applications.vscode.enabled %}
    # VS Code
    if [ -d "$HOME/Library/Application Support/Code/User" ]; then
        mkdir -p "$backup_dir/configs/vscode"
        cp -r "$HOME/Library/Application Support/Code/User/settings.json" "$backup_dir/configs/vscode/" 2>/dev/null || true
        cp -r "$HOME/Library/Application Support/Code/User/keybindings.json" "$backup_dir/configs/vscode/" 2>/dev/null || true
        cp -r "$HOME/Library/Application Support/Code/User/snippets" "$backup_dir/configs/vscode/" 2>/dev/null || true
        code --list-extensions > "$backup_dir/configs/vscode/extensions.list" 2>/dev/null || true
        success "VS Code configuration backed up"
    fi
    {% endif %}
    
    {% if backup_applications.terminal.enabled %}
    # Terminal configurations
    mkdir -p "$backup_dir/configs/terminal"
    cp -r "$HOME/.config/alacritty" "$backup_dir/configs/terminal/" 2>/dev/null || true
    cp "$HOME/.zshrc" "$backup_dir/configs/terminal/" 2>/dev/null || true
    cp "$HOME/.zpreztorc" "$backup_dir/configs/terminal/" 2>/dev/null || true
    success "Terminal configuration backed up"
    {% endif %}
    
    {% if backup_applications.git.enabled %}
    # Git configuration
    mkdir -p "$backup_dir/configs/git"
    cp "$HOME/.gitconfig" "$backup_dir/configs/git/" 2>/dev/null || true
    cp "$HOME/.gitignore_global" "$backup_dir/configs/git/" 2>/dev/null || true
    success "Git configuration backed up"
    {% endif %}
    
    {% if backup_applications.homebrew.enabled %}
    # Homebrew package lists
    mkdir -p "$backup_dir/configs/homebrew"
    brew list > "$backup_dir/configs/homebrew/packages.list" 2>/dev/null || true
    brew list --cask > "$backup_dir/configs/homebrew/casks.list" 2>/dev/null || true
    brew tap > "$backup_dir/configs/homebrew/taps.list" 2>/dev/null || true
    success "Homebrew configuration backed up"
    {% endif %}
    
    # Use mackup for additional application configs
    {% if backup_components.applications %}
    if command -v mackup >/dev/null 2>&1; then
        MACKUP_BACKUP_DIR="$backup_dir/configs/mackup"
        mkdir -p "$MACKUP_BACKUP_DIR"
        # Temporarily override mackup config
        echo "[storage]" > /tmp/mackup_temp.cfg
        echo "engine = file_system" >> /tmp/mackup_temp.cfg
        echo "path = $MACKUP_BACKUP_DIR" >> /tmp/mackup_temp.cfg
        
        MACKUP_CONFIG_FILE=/tmp/mackup_temp.cfg mackup backup --force >/dev/null 2>&1 || true
        rm -f /tmp/mackup_temp.cfg
        success "Additional applications backed up via mackup"
    fi
    {% endif %}
}

backup_security_items() {
    local backup_dir="$1"
    log "Backing up security items..."
    
    {% if backup_applications.ssh.enabled %}
    # SSH configuration (public keys and config only by default)
    if [ -d "$HOME/.ssh" ]; then
        mkdir -p "$backup_dir/security/ssh"
        cp "$HOME/.ssh/config" "$backup_dir/security/ssh/" 2>/dev/null || true
        cp "$HOME/.ssh/known_hosts" "$backup_dir/security/ssh/" 2>/dev/null || true
        cp "$HOME/.ssh"/*.pub "$backup_dir/security/ssh/" 2>/dev/null || true
        
        {% if backup_applications.ssh.private_keys %}
        # Encrypt private keys if enabled
        if [ "$ENCRYPTION_ENABLED" = "true" ]; then
            for key in "$HOME/.ssh"/id_*; do
                if [[ -f "$key" && ! "$key" =~ \.pub$ ]]; then
                    gpg --encrypt --recipient "dotfiles-backup" "$key" > "$backup_dir/security/ssh/$(basename "$key").gpg"
                fi
            done
        fi
        {% endif %}
        
        success "SSH configuration backed up"
    fi
    {% endif %}
    
    # GPG keys
    if command -v gpg >/dev/null 2>&1; then
        gpg --export --armor > "$backup_dir/security/gpg_public_keys.asc" 2>/dev/null || true
        gpg --export-secret-keys --armor > "$backup_dir/security/gpg_private_keys.asc" 2>/dev/null || true
        success "GPG keys backed up"
    fi
}

backup_development_environment() {
    local backup_dir="$1"
    log "Backing up development environment..."
    
    mkdir -p "$backup_dir/development"
    
    {% if backup_development.languages.python.enabled %}
    # Python environment
    pip list --freeze > "$backup_dir/development/python_packages.txt" 2>/dev/null || true
    cp "$HOME/.pypirc" "$backup_dir/development/" 2>/dev/null || true
    {% endif %}
    
    {% if backup_development.languages.node.enabled %}
    # Node.js environment  
    npm list -g --depth=0 > "$backup_dir/development/npm_global_packages.txt" 2>/dev/null || true
    cp "$HOME/.npmrc" "$backup_dir/development/" 2>/dev/null || true
    {% endif %}
    
    {% if backup_development.languages.rust.enabled %}
    # Rust environment
    cargo install --list > "$backup_dir/development/cargo_packages.txt" 2>/dev/null || true
    cp "$HOME/.cargo/config.toml" "$backup_dir/development/" 2>/dev/null || true
    {% endif %}
    
    {% if backup_development.tools.mise.enabled %}
    # mise configuration
    cp -r "$HOME/.config/mise" "$backup_dir/development/" 2>/dev/null || true
    cp "$HOME/.tool-versions" "$backup_dir/development/" 2>/dev/null || true
    {% endif %}
    
    success "Development environment backed up"
}

backup_macos_preferences() {
    local backup_dir="$1"
    log "Backing up macOS preferences..."
    
    mkdir -p "$backup_dir/system/preferences"
    
    {% for domain in backup_applications.macos.domains %}
    defaults export {{ domain }} "$backup_dir/system/preferences/{{ domain }}.plist" 2>/dev/null || true
    {% endfor %}
    
    # Current system version and hardware info
    system_profiler SPSoftwareDataType > "$backup_dir/system/software_info.txt" 2>/dev/null || true
    system_profiler SPHardwareDataType > "$backup_dir/system/hardware_info.txt" 2>/dev/null || true
    
    success "macOS preferences backed up"
}

encrypt_backup() {
    local backup_dir="$1"
    
    if [ "$ENCRYPTION_ENABLED" = "true" ]; then
        log "Encrypting sensitive backup data..."
        
        # Encrypt security directory
        if [ -d "$backup_dir/security" ]; then
            tar -czf - -C "$backup_dir" security | gpg --encrypt --recipient "dotfiles-backup" > "$backup_dir/security.tar.gz.gpg"
            rm -rf "$backup_dir/security"
            success "Security data encrypted"
        fi
    fi
}

sync_to_external_drive() {
    local backup_dir="$1"
    local backup_name="$2"
    
    if check_backup_drive; then
        log "Syncing backup to external drive..."
        local external_backup_dir="$BACKUP_BASE_DIR/$backup_name"
        mkdir -p "$external_backup_dir"
        
        rsync -av --delete "$backup_dir/" "$external_backup_dir/"
        success "Backup synced to external drive: $external_backup_dir"
    fi
}

cleanup_old_backups() {
    log "Cleaning up old backups..."
    
    # Remove backups older than retention period
    find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" -mtime +{{ backup_retention_days }} -exec rm -rf {} \; 2>/dev/null || true
    
    if check_backup_drive; then
        find "$BACKUP_BASE_DIR" -maxdepth 1 -type d -name "*_*" -mtime +{{ backup_retention_days }} -exec rm -rf {} \; 2>/dev/null || true
    fi
    
    success "Old backups cleaned up"
}

# Main execution
main() {
    local full_backup=false
    local config_only=false
    local with_projects=false
    local phase=""
    local custom_name=""
    local force_encrypt=""
    local quiet=false
    local initialize=false
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --full)
                full_backup=true
                shift
                ;;
            --config-only)
                config_only=true
                shift
                ;;
            --with-projects)
                with_projects=true
                shift
                ;;
            --phase)
                phase="$2"
                shift 2
                ;;
            --name)
                custom_name="$2"
                shift 2
                ;;
            --encrypt)
                force_encrypt="true"
                shift
                ;;
            --no-encrypt)
                force_encrypt="false"
                shift
                ;;
            --quiet)
                quiet=true
                shift
                ;;
            --initialize)
                initialize=true
                shift
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    # Initialize backup system if requested
    if [ "$initialize" = "true" ]; then
        mkdir -p "$BACKUP_LOCAL_DIR"/{checkpoints,configs,security,logs}
        touch "$BACKUP_LOCAL_DIR/initialized"
        success "Backup system initialized"
        exit 0
    fi
    
    # Set backup name
    local backup_name
    if [ -n "$custom_name" ]; then
        backup_name="${custom_name}_${TIMESTAMP}"
    elif [ -n "$phase" ]; then
        backup_name="${phase}_${TIMESTAMP}"
    elif [ "$config_only" = "true" ]; then
        backup_name="config_${TIMESTAMP}"
    elif [ "$full_backup" = "true" ]; then
        backup_name="full_${TIMESTAMP}"
    else
        backup_name="backup_${TIMESTAMP}"
    fi
    
    # Override encryption setting if forced
    if [ -n "$force_encrypt" ]; then
        ENCRYPTION_ENABLED="$force_encrypt"
    fi
    
    if [ "$quiet" = "false" ]; then
        log "Starting backup: $backup_name"
    fi
    
    check_dependencies
    local backup_dir=$(create_backup_structure "$backup_name")
    
    # Perform backup based on options
    if [ "$full_backup" = "true" ] || [ "$config_only" = "false" ]; then
        backup_application_configs "$backup_dir"
        backup_security_items "$backup_dir"
        backup_development_environment "$backup_dir"
        backup_macos_preferences "$backup_dir"
    elif [ "$config_only" = "true" ]; then
        backup_application_configs "$backup_dir"
    fi
    
    encrypt_backup "$backup_dir"
    sync_to_external_drive "$backup_dir" "$backup_name"
    
    if [ "$full_backup" = "true" ]; then
        cleanup_old_backups
    fi
    
    if [ "$quiet" = "false" ]; then
        success "Backup completed: $backup_name"
        log "Backup location: $backup_dir"
        if check_backup_drive; then
            log "External backup: $BACKUP_BASE_DIR/$backup_name"
        fi
    fi
}

# Ensure script directory exists
mkdir -p "$(dirname "$LOGFILE")"

# Run main function
main "$@"