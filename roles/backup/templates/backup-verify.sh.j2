#!/bin/bash
# Backup Verification Script
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

# Configuration
BACKUP_LOCAL_DIR="{{ backup_local_dir }}"
BACKUP_BASE_DIR="{{ backup_base_dir }}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
}

success() {
    echo -e "${GREEN}✅ $1${NC}"
}

warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

error() {
    echo -e "${RED}❌ $1${NC}"
}

show_usage() {
    cat << EOF
Usage: backup-verify [OPTIONS] [BACKUP_NAME]

OPTIONS:
    --all               Verify all backups
    --latest            Verify latest backup only
    --quick             Quick verification (metadata only)
    --deep              Deep verification (checksums)
    --repair            Attempt to repair corrupted backups
    --help              Show this help message

EXAMPLES:
    backup-verify                           # Verify latest backup
    backup-verify --all                     # Verify all backups
    backup-verify full_20240125_143022      # Verify specific backup
    backup-verify --deep latest             # Deep verification of latest
EOF
}

verify_backup_metadata() {
    local backup_path="$1"
    local backup_name=$(basename "$backup_path")
    
    log "Verifying metadata for: $backup_name"
    
    # Check if backup directory exists
    if [ ! -d "$backup_path" ]; then
        error "Backup directory not found: $backup_path"
        return 1
    fi
    
    # Check metadata directory
    if [ ! -d "$backup_path/metadata" ]; then
        error "Metadata directory missing"
        return 1
    fi
    
    # Check required metadata files
    local required_files=("timestamp")
    for file in "${required_files[@]}"; do
        if [ ! -f "$backup_path/metadata/$file" ]; then
            error "Missing metadata file: $file"
            return 1
        fi
    done
    
    # Verify timestamp format
    local timestamp=$(cat "$backup_path/metadata/timestamp")
    if ! [[ "$timestamp" =~ ^[0-9]{8}_[0-9]{6}$ ]]; then
        error "Invalid timestamp format: $timestamp"
        return 1
    fi
    
    # Check for required backup components
    local found_components=0
    [ -d "$backup_path/configs" ] && ((found_components++))
    [ -d "$backup_path/security" ] || [ -f "$backup_path/security.tar.gz.gpg" ] && ((found_components++))
    [ -d "$backup_path/development" ] && ((found_components++))
    [ -d "$backup_path/system" ] && ((found_components++))
    
    if [ "$found_components" -eq 0 ]; then
        error "No backup components found"
        return 1
    fi
    
    success "Metadata verification passed"
    return 0
}

verify_backup_integrity() {
    local backup_path="$1"
    local deep_check="$2"
    local backup_name=$(basename "$backup_path")
    
    log "Verifying integrity for: $backup_name"
    
    # Basic metadata check
    if ! verify_backup_metadata "$backup_path"; then
        return 1
    fi
    
    # Check file permissions
    if [ ! -r "$backup_path" ]; then
        error "Backup directory not readable"
        return 1
    fi
    
    # Verify encrypted security data
    {% if backup_encryption.enabled %}
    if [ -f "$backup_path/security.tar.gz.gpg" ]; then
        log "Verifying encrypted security data..."
        if gpg --decrypt "$backup_path/security.tar.gz.gpg" >/dev/null 2>&1; then
            success "Security data decryption test passed"
        else
            error "Cannot decrypt security data"
            return 1
        fi
    fi
    {% endif %}
    
    # Deep verification with checksums
    if [ "$deep_check" = "true" ]; then
        log "Performing deep integrity check..."
        
        # Create checksums file if it doesn't exist
        local checksums_file="$backup_path/metadata/checksums.sha256"
        if [ ! -f "$checksums_file" ]; then
            warning "Checksums file missing, creating one..."
            find "$backup_path" -type f ! -path "*/metadata/checksums.sha256" -exec sha256sum {} \; > "$checksums_file"
        fi
        
        # Verify checksums
        local checksum_errors=0
        while IFS= read -r line; do
            local expected_hash=$(echo "$line" | cut -d' ' -f1)
            local file_path=$(echo "$line" | cut -d' ' -f3-)
            
            if [ -f "$file_path" ]; then
                local actual_hash=$(sha256sum "$file_path" | cut -d' ' -f1)
                if [ "$expected_hash" != "$actual_hash" ]; then
                    error "Checksum mismatch: $(basename "$file_path")"
                    ((checksum_errors++))
                fi
            else
                error "Missing file: $(basename "$file_path")"
                ((checksum_errors++))
            fi
        done < "$checksums_file"
        
        if [ "$checksum_errors" -eq 0 ]; then
            success "Deep integrity check passed"
        else
            error "Deep integrity check failed ($checksum_errors errors)"
            return 1
        fi
    fi
    
    success "Integrity verification passed"
    return 0
}

repair_backup() {
    local backup_path="$1"
    local backup_name=$(basename "$backup_path")
    
    warning "Attempting to repair backup: $backup_name"
    
    # Check if external backup exists for repair
    local external_backup="$BACKUP_BASE_DIR/$backup_name"
    if [ -d "$external_backup" ]; then
        log "Found external backup, syncing to repair local copy..."
        rsync -av --delete "$external_backup/" "$backup_path/"
        success "Repair completed from external backup"
        return 0
    fi
    
    # Try to recreate missing metadata
    if [ ! -d "$backup_path/metadata" ]; then
        log "Recreating missing metadata..."
        mkdir -p "$backup_path/metadata"
        
        # Extract timestamp from directory name
        if [[ "$backup_name" =~ _([0-9]{8}_[0-9]{6})$ ]]; then
            echo "${BASH_REMATCH[1]}" > "$backup_path/metadata/timestamp"
        fi
        
        # Add system info if possible
        uname -a > "$backup_path/metadata/system_info" 2>/dev/null || true
        sw_vers > "$backup_path/metadata/macos_version" 2>/dev/null || true
    fi
    
    warning "Partial repair completed, verification recommended"
    return 0
}

verify_all_backups() {
    local quick_mode="$1"
    local deep_mode="$2"
    
    log "Verifying all backups..."
    
    local total_backups=0
    local failed_backups=0
    
    # Verify local backups
    while IFS= read -r -d '' backup_path; do
        ((total_backups++))
        if [ "$quick_mode" = "true" ]; then
            verify_backup_metadata "$backup_path" || ((failed_backups++))
        else
            verify_backup_integrity "$backup_path" "$deep_mode" || ((failed_backups++))
        fi
        echo
    done < <(find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" -print0 2>/dev/null || true)
    
    # Verify checkpoints
    while IFS= read -r -d '' checkpoint_path; do
        ((total_backups++))
        if [ "$quick_mode" = "true" ]; then
            verify_backup_metadata "$checkpoint_path" || ((failed_backups++))
        else
            verify_backup_integrity "$checkpoint_path" "$deep_mode" || ((failed_backups++))
        fi
        echo
    done < <(find "$BACKUP_LOCAL_DIR/checkpoints" -maxdepth 1 -type d -name "*_*" -print0 2>/dev/null || true)
    
    # Summary
    if [ "$failed_backups" -eq 0 ]; then
        success "All $total_backups backups verified successfully"
    else
        error "$failed_backups out of $total_backups backups failed verification"
        return 1
    fi
}

# Main execution
main() {
    local verify_all=false
    local verify_latest=false
    local quick_mode=false
    local deep_mode=false
    local repair_mode=false
    local backup_name=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --all)
                verify_all=true
                shift
                ;;
            --latest)
                verify_latest=true
                shift
                ;;
            --quick)
                quick_mode=true
                shift
                ;;
            --deep)
                deep_mode=true
                shift
                ;;
            --repair)
                repair_mode=true
                shift
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                backup_name="$1"
                shift
                ;;
        esac
    done
    
    # Execute verification
    if [ "$verify_all" = "true" ]; then
        verify_all_backups "$quick_mode" "$deep_mode"
    elif [ "$verify_latest" = "true" ] || [ -z "$backup_name" ]; then
        # Find latest backup
        local latest_backup=$(find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -1)
        if [ -z "$latest_backup" ]; then
            error "No backups found"
            exit 1
        fi
        
        if [ "$repair_mode" = "true" ]; then
            repair_backup "$latest_backup"
        elif [ "$quick_mode" = "true" ]; then
            verify_backup_metadata "$latest_backup"
        else
            verify_backup_integrity "$latest_backup" "$deep_mode"
        fi
    else
        # Verify specific backup
        local backup_path=""
        
        # Try to find the backup
        if [ -d "$BACKUP_LOCAL_DIR/$backup_name" ]; then
            backup_path="$BACKUP_LOCAL_DIR/$backup_name"
        elif [ -d "$BACKUP_LOCAL_DIR/checkpoints/$backup_name" ]; then
            backup_path="$BACKUP_LOCAL_DIR/checkpoints/$backup_name"
        else
            # Try partial match
            backup_path=$(find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*${backup_name}*" | head -1)
            if [ -z "$backup_path" ]; then
                backup_path=$(find "$BACKUP_LOCAL_DIR/checkpoints" -maxdepth 1 -type d -name "*${backup_name}*" | head -1)
            fi
        fi
        
        if [ -z "$backup_path" ]; then
            error "Backup not found: $backup_name"
            exit 1
        fi
        
        if [ "$repair_mode" = "true" ]; then
            repair_backup "$backup_path"
        elif [ "$quick_mode" = "true" ]; then
            verify_backup_metadata "$backup_path"
        else
            verify_backup_integrity "$backup_path" "$deep_mode"
        fi
    fi
}

main "$@"