#!/bin/bash
# Backup Rollback and Recovery Script
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

# Configuration
BACKUP_LOCAL_DIR="{{ backup_local_dir }}"
CHECKPOINT_DIR="$BACKUP_LOCAL_DIR/checkpoints"
TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
LOGFILE="$BACKUP_LOCAL_DIR/logs/rollback_$TIMESTAMP.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOGFILE"
}

success() {
    echo -e "${GREEN}✅ $1${NC}" | tee -a "$LOGFILE"
}

warning() {
    echo -e "${YELLOW}⚠️  $1${NC}" | tee -a "$LOGFILE"
}

error() {
    echo -e "${RED}❌ $1${NC}" | tee -a "$LOGFILE"
    exit 1
}

show_usage() {
    cat << EOF
Usage: backup-rollback [COMMAND] [OPTIONS]

COMMANDS:
    bootstrap          Roll back bootstrap process to specific phase
    config FILE        Roll back specific configuration file
    application APP    Roll back specific application settings
    system DOMAIN      Roll back system preferences domain
    full CHECKPOINT    Complete rollback to checkpoint state
    emergency          Emergency recovery to last known good state

OPTIONS:
    --to CHECKPOINT    Target checkpoint for rollback
    --phase PHASE      Bootstrap phase to roll back to
    --dry-run          Show what would be rolled back
    --force            Skip confirmation prompts
    --backup-current   Create backup before rollback
    --interactive      Interactive selection mode
    --list-phases      Show available bootstrap phases
    --help             Show this help message

BOOTSTRAP PHASES:
    pre-ansible        Before any Ansible automation
    pre-homebrew       Before Homebrew installation
    pre-dotfiles       Before dotfiles installation
    pre-applications   Before application installation
    post-setup         After complete setup

EXAMPLES:
    backup-rollback bootstrap --phase pre-homebrew        # Roll back to before Homebrew
    backup-rollback config .zshrc --to latest            # Restore .zshrc from latest checkpoint
    backup-rollback application vscode                    # Roll back VS Code settings
    backup-rollback system com.apple.dock                # Restore dock preferences
    backup-rollback full pre-setup_20240125_143022       # Complete rollback to checkpoint
    backup-rollback emergency                             # Emergency recovery

SAFETY FEATURES:
    - Always creates backup before rollback
    - Validates checkpoint integrity before proceeding
    - Supports dry-run mode for previewing changes
    - Tracks rollback history for debugging
    - Provides emergency recovery option
EOF
}

find_checkpoint_by_phase() {
    local target_phase="$1"
    
    local checkpoint=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*_*" | while read -r cp; do
        if [ -f "$cp/metadata/checkpoint.json" ]; then
            local phase=$(grep '"bootstrap_phase"' "$cp/metadata/checkpoint.json" 2>/dev/null | cut -d'"' -f4 || echo "")
            if [ "$phase" = "$target_phase" ]; then
                echo "$cp"
                break
            fi
        fi
    done | head -1)
    
    echo "$checkpoint"
}

validate_checkpoint() {
    local checkpoint_path="$1"
    
    if [ ! -d "$checkpoint_path" ]; then
        error "Checkpoint directory not found: $checkpoint_path"
    fi
    
    if [ ! -f "$checkpoint_path/metadata/checkpoint.json" ]; then
        error "Checkpoint metadata not found: $checkpoint_path/metadata/checkpoint.json"
    fi
    
    if [ ! -f "$checkpoint_path/recover.sh" ]; then
        error "Recovery script not found: $checkpoint_path/recover.sh"
    fi
    
    # Verify checkpoint integrity
    local timestamp=$(grep '"timestamp"' "$checkpoint_path/metadata/checkpoint.json" 2>/dev/null | cut -d'"' -f4 || echo "")
    if [ -z "$timestamp" ]; then
        error "Invalid checkpoint metadata"
    fi
    
    success "Checkpoint validation passed: $(basename "$checkpoint_path")"
}

create_rollback_backup() {
    log "Creating backup before rollback..."
    
    if command -v backup-create >/dev/null 2>&1; then
        backup-create --config-only --name "pre-rollback" --description "Backup before rollback to $(basename "$1")" --quiet
        success "Pre-rollback backup created"
    else
        warning "backup-create not available, skipping pre-rollback backup"
    fi
}

rollback_bootstrap_phase() {
    local target_phase="$1"
    local dry_run="$2"
    local force="$3"
    local backup_current="$4"
    
    log "Rolling back bootstrap process to phase: $target_phase"
    
    # Find checkpoint for target phase
    local checkpoint_path=$(find_checkpoint_by_phase "$target_phase")
    if [ -z "$checkpoint_path" ]; then
        error "No checkpoint found for phase: $target_phase"
    fi
    
    validate_checkpoint "$checkpoint_path"
    
    if [ "$dry_run" = "true" ]; then
        log "Would roll back to checkpoint: $(basename "$checkpoint_path")"
        show_rollback_preview "$checkpoint_path"
        return 0
    fi
    
    # Confirm unless forced
    if [ "$force" = "false" ]; then
        echo -e "\n${YELLOW}WARNING: This will roll back your system to the '$target_phase' state!${NC}"
        echo "This may undo recent changes and installations."
        read -p "Continue with rollback? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Rollback cancelled"
            exit 0
        fi
    fi
    
    # Create backup if requested
    if [ "$backup_current" = "true" ]; then
        create_rollback_backup "$checkpoint_path"
    fi
    
    # Perform rollback
    execute_rollback "$checkpoint_path" "$target_phase"
}

rollback_config_file() {
    local config_file="$1"
    local checkpoint_name="$2"
    local dry_run="$3"
    local force="$4"
    
    log "Rolling back configuration file: $config_file"
    
    # Find checkpoint
    local checkpoint_path=""
    if [ "$checkpoint_name" = "latest" ]; then
        checkpoint_path=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -1)
    else
        checkpoint_path=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "${checkpoint_name}_*" | head -1)
    fi
    
    if [ -z "$checkpoint_path" ]; then
        error "Checkpoint not found: $checkpoint_name"
    fi
    
    validate_checkpoint "$checkpoint_path"
    
    # Check if config file exists in checkpoint
    local config_path="$checkpoint_path/configs/${config_file#~/}"
    config_path="${config_path#$HOME/}"
    
    if [ ! -f "$config_path" ]; then
        error "Configuration file not found in checkpoint: $config_file"
    fi
    
    if [ "$dry_run" = "true" ]; then
        log "Would restore $config_file from checkpoint: $(basename "$checkpoint_path")"
        echo "  Source: $config_path"
        echo "  Target: $HOME/$config_file"
        return 0
    fi
    
    # Confirm unless forced
    if [ "$force" = "false" ]; then
        echo -e "\n${YELLOW}WARNING: This will overwrite your current $config_file!${NC}"
        read -p "Continue with file rollback? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Rollback cancelled"
            exit 0
        fi
    fi
    
    # Backup current file
    local target_file="$HOME/$config_file"
    if [ -f "$target_file" ]; then
        cp "$target_file" "${target_file}.pre-rollback-${TIMESTAMP}"
        log "Current file backed up: ${target_file}.pre-rollback-${TIMESTAMP}"
    fi
    
    # Restore file
    mkdir -p "$(dirname "$target_file")"
    cp "$config_path" "$target_file"
    success "Configuration file restored: $config_file"
}

rollback_application() {
    local app_name="$1"
    local checkpoint_name="$2"
    local dry_run="$3"
    local force="$4"
    
    log "Rolling back application settings: $app_name"
    
    # Find checkpoint
    local checkpoint_path=""
    if [ "$checkpoint_name" = "latest" ]; then
        checkpoint_path=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -1)
    else
        checkpoint_path=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "${checkpoint_name}_*" | head -1)
    fi
    
    if [ -z "$checkpoint_path" ]; then
        error "Checkpoint not found: $checkpoint_name"
    fi
    
    validate_checkpoint "$checkpoint_path"
    
    if [ "$dry_run" = "true" ]; then
        log "Would restore $app_name settings from checkpoint: $(basename "$checkpoint_path")"
        show_app_rollback_preview "$checkpoint_path" "$app_name"
        return 0
    fi
    
    # Confirm unless forced
    if [ "$force" = "false" ]; then
        echo -e "\n${YELLOW}WARNING: This will overwrite your current $app_name settings!${NC}"
        read -p "Continue with application rollback? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Rollback cancelled"
            exit 0
        fi
    fi
    
    # Restore application settings
    restore_application_settings "$checkpoint_path" "$app_name"
}

rollback_system_domain() {
    local domain="$1"
    local checkpoint_name="$2"
    local dry_run="$3"
    local force="$4"
    
    log "Rolling back system preferences domain: $domain"
    
    # Find checkpoint
    local checkpoint_path=""
    if [ "$checkpoint_name" = "latest" ]; then
        checkpoint_path=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -1)
    else
        checkpoint_path=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "${checkpoint_name}_*" | head -1)
    fi
    
    if [ -z "$checkpoint_path" ]; then
        error "Checkpoint not found: $checkpoint_name"
    fi
    
    validate_checkpoint "$checkpoint_path"
    
    local plist_file="$checkpoint_path/configs/system/${domain}.plist"
    if [ ! -f "$plist_file" ]; then
        error "System preferences not found in checkpoint: $domain"
    fi
    
    if [ "$dry_run" = "true" ]; then
        log "Would restore $domain preferences from checkpoint: $(basename "$checkpoint_path")"
        echo "  Source: $plist_file"
        return 0
    fi
    
    # Confirm unless forced
    if [ "$force" = "false" ]; then
        echo -e "\n${YELLOW}WARNING: This will overwrite your current $domain preferences!${NC}"
        read -p "Continue with system preferences rollback? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Rollback cancelled"
            exit 0
        fi
    fi
    
    # Backup current preferences
    defaults export "$domain" "/tmp/${domain}.pre-rollback-${TIMESTAMP}.plist" 2>/dev/null || true
    
    # Restore preferences
    defaults import "$domain" "$plist_file"
    success "System preferences restored: $domain"
    warning "You may need to restart affected applications or log out/in for changes to take effect"
}

full_rollback() {
    local checkpoint_name="$1"
    local dry_run="$2"
    local force="$3"
    local backup_current="$4"
    
    log "Performing full rollback to checkpoint: $checkpoint_name"
    
    # Find checkpoint
    local checkpoint_path=""
    if [ "$checkpoint_name" = "latest" ]; then
        checkpoint_path=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -1)
    else
        checkpoint_path=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "${checkpoint_name}_*" | head -1)
    fi
    
    if [ -z "$checkpoint_path" ]; then
        error "Checkpoint not found: $checkpoint_name"
    fi
    
    validate_checkpoint "$checkpoint_path"
    
    if [ "$dry_run" = "true" ]; then
        log "Would perform full rollback to checkpoint: $(basename "$checkpoint_path")"
        show_rollback_preview "$checkpoint_path"
        return 0
    fi
    
    # Confirm unless forced
    if [ "$force" = "false" ]; then
        echo -e "\n${YELLOW}WARNING: This will perform a complete rollback to checkpoint state!${NC}"
        echo "This will overwrite all configurations, applications settings, and system preferences."
        read -p "Continue with full rollback? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Rollback cancelled"
            exit 0
        fi
    fi
    
    # Create backup if requested
    if [ "$backup_current" = "true" ]; then
        create_rollback_backup "$checkpoint_path"
    fi
    
    # Execute full rollback
    execute_rollback "$checkpoint_path" "full"
}

emergency_recovery() {
    local dry_run="$1"
    local force="$2"
    
    log "Initiating emergency recovery..."
    
    # Find the most recent checkpoint
    local latest_checkpoint=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -1)
    if [ -z "$latest_checkpoint" ]; then
        error "No checkpoints available for emergency recovery"
    fi
    
    log "Emergency recovery will use checkpoint: $(basename "$latest_checkpoint")"
    
    if [ "$dry_run" = "true" ]; then
        log "Would perform emergency recovery using: $(basename "$latest_checkpoint")"
        show_rollback_preview "$latest_checkpoint"
        return 0
    fi
    
    # In emergency mode, skip most confirmations but show critical warning
    if [ "$force" = "false" ]; then
        echo -e "\n${RED}EMERGENCY RECOVERY MODE${NC}"
        echo -e "${YELLOW}This will restore your system to the last checkpoint state.${NC}"
        read -p "Continue with emergency recovery? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Emergency recovery cancelled"
            exit 0
        fi
    fi
    
    # Execute emergency recovery (skip backup creation in emergency)
    execute_rollback "$latest_checkpoint" "emergency"
}

execute_rollback() {
    local checkpoint_path="$1"
    local rollback_type="$2"
    
    log "Executing rollback from checkpoint: $(basename "$checkpoint_path")"
    
    # Record rollback attempt
    echo "$(date -Iseconds): Rollback $rollback_type to $(basename "$checkpoint_path")" >> "$BACKUP_LOCAL_DIR/logs/rollback_history.log"
    
    # Execute the checkpoint's recovery script
    if [ -f "$checkpoint_path/recover.sh" ]; then
        log "Running checkpoint recovery script..."
        bash "$checkpoint_path/recover.sh"
        success "Rollback completed successfully"
    else
        error "Recovery script not found in checkpoint"
    fi
    
    # Update rollback history
    echo "$(date -Iseconds): Rollback $rollback_type completed successfully" >> "$BACKUP_LOCAL_DIR/logs/rollback_history.log"
    
    # Post-rollback recommendations
    echo
    echo -e "${BOLD}Post-Rollback Recommendations:${NC}"
    echo "1. Restart any affected applications"
    echo "2. Check terminal/shell settings by opening a new session"
    echo "3. Verify critical applications are working correctly"
    echo "4. Review system preferences for any needed adjustments"
    
    if [ "$rollback_type" = "emergency" ]; then
        echo "5. Consider creating a new checkpoint after verifying system stability"
    fi
}

show_rollback_preview() {
    local checkpoint_path="$1"
    
    echo -e "\n${BOLD}Rollback Preview:${NC}"
    
    # Show checkpoint metadata
    if [ -f "$checkpoint_path/metadata/checkpoint.json" ]; then
        local name=$(grep '"name"' "$checkpoint_path/metadata/checkpoint.json" | cut -d'"' -f4)
        local description=$(grep '"description"' "$checkpoint_path/metadata/checkpoint.json" | cut -d'"' -f4)
        local created_at=$(grep '"created_at"' "$checkpoint_path/metadata/checkpoint.json" | cut -d'"' -f4)
        local phase=$(grep '"bootstrap_phase"' "$checkpoint_path/metadata/checkpoint.json" | cut -d'"' -f4)
        
        echo "  Name: $name"
        echo "  Description: $description"
        echo "  Created: $created_at"
        [ "$phase" != "unknown" ] && echo "  Phase: $phase"
    fi
    
    echo
    echo "Files that would be restored:"
    
    # List configuration files
    if [ -d "$checkpoint_path/configs" ]; then
        find "$checkpoint_path/configs" -type f | while read -r file; do
            local rel_path="${file#$checkpoint_path/configs/}"
            echo "  📁 $rel_path"
        done
    fi
    
    # List system preferences
    if [ -d "$checkpoint_path/configs/system" ]; then
        echo
        echo "System preferences that would be restored:"
        find "$checkpoint_path/configs/system" -name "*.plist" | while read -r plist; do
            local domain=$(basename "$plist" .plist)
            echo "  ⚙️  $domain"
        done
    fi
}

show_app_rollback_preview() {
    local checkpoint_path="$1"
    local app_name="$2"
    
    echo "Application settings that would be restored for $app_name:"
    
    case "$app_name" in
        vscode)
            [ -d "$checkpoint_path/configs/vscode" ] && echo "  📝 VS Code settings, keybindings, and snippets"
            ;;
        git)
            [ -f "$checkpoint_path/configs/.gitconfig" ] && echo "  🔧 Git configuration"
            [ -f "$checkpoint_path/configs/.gitignore_global" ] && echo "  🚫 Global gitignore"
            ;;
        ssh)
            [ -d "$checkpoint_path/configs/.ssh" ] && echo "  🔐 SSH configuration and keys"
            ;;
        terminal)
            [ -f "$checkpoint_path/configs/.zshrc" ] && echo "  🐚 Zsh configuration"
            [ -f "$checkpoint_path/configs/.zpreztorc" ] && echo "  ⚡ Prezto configuration"
            [ -d "$checkpoint_path/configs/alacritty" ] && echo "  💻 Alacritty terminal configuration"
            ;;
        *)
            echo "  ❓ Unknown application: $app_name"
            ;;
    esac
}

restore_application_settings() {
    local checkpoint_path="$1"
    local app_name="$2"
    
    case "$app_name" in
        vscode)
            if [ -d "$checkpoint_path/configs/vscode" ]; then
                local vscode_dir="$HOME/Library/Application Support/Code/User"
                mkdir -p "$vscode_dir"
                [ -f "$checkpoint_path/configs/vscode/settings.json" ] && cp "$checkpoint_path/configs/vscode/settings.json" "$vscode_dir/"
                [ -f "$checkpoint_path/configs/vscode/keybindings.json" ] && cp "$checkpoint_path/configs/vscode/keybindings.json" "$vscode_dir/"
                [ -d "$checkpoint_path/configs/vscode/snippets" ] && cp -r "$checkpoint_path/configs/vscode/snippets" "$vscode_dir/"
                success "VS Code settings restored"
            fi
            ;;
        git)
            [ -f "$checkpoint_path/configs/.gitconfig" ] && cp "$checkpoint_path/configs/.gitconfig" "$HOME/"
            [ -f "$checkpoint_path/configs/.gitignore_global" ] && cp "$checkpoint_path/configs/.gitignore_global" "$HOME/"
            success "Git configuration restored"
            ;;
        ssh)
            if [ -d "$checkpoint_path/configs/.ssh" ]; then
                mkdir -p "$HOME/.ssh"
                cp -r "$checkpoint_path/configs/.ssh"/* "$HOME/.ssh/"
                chmod 700 "$HOME/.ssh"
                chmod 600 "$HOME/.ssh"/* 2>/dev/null || true
                success "SSH configuration restored"
            fi
            ;;
        terminal)
            [ -f "$checkpoint_path/configs/.zshrc" ] && cp "$checkpoint_path/configs/.zshrc" "$HOME/"
            [ -f "$checkpoint_path/configs/.zpreztorc" ] && cp "$checkpoint_path/configs/.zpreztorc" "$HOME/"
            [ -d "$checkpoint_path/configs/alacritty" ] && cp -r "$checkpoint_path/configs/alacritty" "$HOME/.config/"
            success "Terminal configuration restored"
            ;;
        *)
            error "Unknown application: $app_name"
            ;;
    esac
}

list_bootstrap_phases() {
    echo -e "${BOLD}Available Bootstrap Phases:${NC}"
    echo
    
    local phases=("pre-ansible" "pre-homebrew" "pre-dotfiles" "pre-applications" "post-setup")
    
    for phase in "${phases[@]}"; do
        local checkpoint=$(find_checkpoint_by_phase "$phase")
        if [ -n "$checkpoint" ]; then
            local created_at=$(grep '"created_at"' "$checkpoint/metadata/checkpoint.json" 2>/dev/null | cut -d'"' -f4 || echo "Unknown")
            printf "  ${GREEN}%-15s${NC} Available (created: %s)\n" "$phase" "$created_at"
        else
            printf "  ${RED}%-15s${NC} No checkpoint available\n" "$phase"
        fi
    done
}

# Main execution
main() {
    local command=""
    local target=""
    local checkpoint_name="latest"
    local target_phase=""
    local dry_run=false
    local force=false
    local backup_current=true
    local interactive=false
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            bootstrap|config|application|system|full|emergency)
                command="$1"
                shift
                ;;
            --to)
                checkpoint_name="$2"
                shift 2
                ;;
            --phase)
                target_phase="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            --backup-current)
                backup_current=true
                shift
                ;;
            --no-backup-current)
                backup_current=false
                shift
                ;;
            --interactive)
                interactive=true
                shift
                ;;
            --list-phases)
                list_bootstrap_phases
                exit 0
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                if [ -z "$target" ]; then
                    target="$1"
                    shift
                else
                    error "Unknown option: $1"
                fi
                ;;
        esac
    done
    
    # Validate command
    if [ -z "$command" ]; then
        show_usage
        exit 1
    fi
    
    # Create log directory
    mkdir -p "$(dirname "$LOGFILE")"
    
    # Execute command
    case "$command" in
        bootstrap)
            [ -z "$target_phase" ] && error "Bootstrap phase required (use --phase option)"
            rollback_bootstrap_phase "$target_phase" "$dry_run" "$force" "$backup_current"
            ;;
        config)
            [ -z "$target" ] && error "Configuration file required"
            rollback_config_file "$target" "$checkpoint_name" "$dry_run" "$force"
            ;;
        application)
            [ -z "$target" ] && error "Application name required"
            rollback_application "$target" "$checkpoint_name" "$dry_run" "$force"
            ;;
        system)
            [ -z "$target" ] && error "System domain required"
            rollback_system_domain "$target" "$checkpoint_name" "$dry_run" "$force"
            ;;
        full)
            [ -z "$target" ] && target="latest"
            full_rollback "$target" "$dry_run" "$force" "$backup_current"
            ;;
        emergency)
            emergency_recovery "$dry_run" "$force"
            ;;
        *)
            error "Unknown command: $command"
            ;;
    esac
}

# Run main function
main "$@"