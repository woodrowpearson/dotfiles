#!/bin/bash
# Bootstrap Checkpoint Management Script
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

# Configuration
BACKUP_LOCAL_DIR="{{ backup_local_dir }}"
CHECKPOINT_DIR="$BACKUP_LOCAL_DIR/checkpoints"
TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
LOGFILE="$BACKUP_LOCAL_DIR/logs/checkpoint_$TIMESTAMP.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOGFILE"
}

success() {
    echo -e "${GREEN}‚úÖ $1${NC}" | tee -a "$LOGFILE"
}

warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}" | tee -a "$LOGFILE"
}

error() {
    echo -e "${RED}‚ùå $1${NC}" | tee -a "$LOGFILE"
    exit 1
}

show_usage() {
    cat << EOF
Usage: backup-checkpoint [COMMAND] [OPTIONS]

COMMANDS:
    create NAME         Create a new checkpoint with given name
    restore NAME        Restore from a checkpoint
    list               List available checkpoints
    delete NAME        Delete a checkpoint
    auto PHASE         Create automatic checkpoint for bootstrap phase

OPTIONS:
    --description TEXT  Description for the checkpoint
    --force            Skip confirmation prompts
    --dry-run          Show what would be done without applying changes
    --include-system   Include system preferences in checkpoint
    --quick            Quick checkpoint (configs only)
    --help             Show this help message

BOOTSTRAP PHASES:
    pre-ansible        Before running any Ansible tasks
    pre-homebrew       Before installing Homebrew packages
    pre-dotfiles       Before installing dotfiles
    pre-applications   Before installing applications
    post-setup         After complete setup

EXAMPLES:
    backup-checkpoint create before-setup --description "Clean system before setup"
    backup-checkpoint auto pre-ansible                    # Automatic pre-Ansible checkpoint
    backup-checkpoint restore before-setup                # Restore to checkpoint
    backup-checkpoint list                                # Show all checkpoints
    backup-checkpoint delete old-checkpoint               # Remove checkpoint

CHECKPOINT STRUCTURE:
    Checkpoints store lightweight snapshots of:
    - Configuration files (.zshrc, .gitconfig, etc.)
    - Application settings (VS Code, Terminal themes)
    - System preferences (selected domains)
    - Package lists (Homebrew, npm, pip)
    - Bootstrap state and progress markers
EOF
}

create_checkpoint() {
    local checkpoint_name="$1"
    local description="$2"
    local include_system="$3"
    local quick_mode="$4"
    local dry_run="$5"
    
    local checkpoint_path="$CHECKPOINT_DIR/${checkpoint_name}_${TIMESTAMP}"
    
    if [ "$dry_run" = "true" ]; then
        log "Would create checkpoint: $checkpoint_name"
        echo "  Path: $checkpoint_path"
        echo "  Include system: $include_system"
        echo "  Quick mode: $quick_mode"
        return 0
    fi
    
    log "Creating checkpoint: $checkpoint_name"
    
    # Create checkpoint structure
    mkdir -p "$checkpoint_path"/{configs,state,metadata,packages}
    
    # Store metadata
    cat > "$checkpoint_path/metadata/checkpoint.json" << EOF
{
    "name": "$checkpoint_name",
    "description": "$description",
    "timestamp": "$TIMESTAMP",
    "created_at": "$(date -Iseconds)",
    "hostname": "$(hostname)",
    "user": "$(whoami)",
    "include_system": $include_system,
    "quick_mode": $quick_mode,
    "macos_version": "$(sw_vers -productVersion)",
    "bootstrap_phase": "${BOOTSTRAP_PHASE:-unknown}"
}
EOF
    
    # Capture current bootstrap state
    capture_bootstrap_state "$checkpoint_path"
    
    # Backup essential configurations
    backup_essential_configs "$checkpoint_path" "$quick_mode"
    
    # Backup package states
    backup_package_states "$checkpoint_path"
    
    # Backup system preferences if requested
    if [ "$include_system" = "true" ] && [ "$quick_mode" = "false" ]; then
        backup_system_preferences "$checkpoint_path"
    fi
    
    # Create recovery script
    create_recovery_script "$checkpoint_path" "$checkpoint_name"
    
    success "Checkpoint created: $checkpoint_path"
    
    # Update latest checkpoint symlink
    rm -f "$CHECKPOINT_DIR/latest"
    ln -sf "$(basename "$checkpoint_path")" "$CHECKPOINT_DIR/latest"
}

capture_bootstrap_state() {
    local checkpoint_path="$1"
    
    # Capture current PATH and environment
    env > "$checkpoint_path/state/environment.txt"
    echo "$PATH" > "$checkpoint_path/state/path.txt"
    
    # Capture shell configuration state
    [ -f "$HOME/.zshrc" ] && cp "$HOME/.zshrc" "$checkpoint_path/state/zshrc.backup"
    [ -f "$HOME/.zpreztorc" ] && cp "$HOME/.zpreztorc" "$checkpoint_path/state/zpreztorc.backup"
    
    # Capture Homebrew state
    if command -v brew >/dev/null 2>&1; then
        echo "homebrew_installed=true" > "$checkpoint_path/state/homebrew_state.txt"
        brew --version >> "$checkpoint_path/state/homebrew_state.txt"
    else
        echo "homebrew_installed=false" > "$checkpoint_path/state/homebrew_state.txt"
    fi
    
    # Capture application installation state
    {
        echo "# Application Installation State"
        echo "vscode_installed=$([ -d "/Applications/Visual Studio Code.app" ] && echo true || echo false)"
        echo "docker_installed=$(command -v docker >/dev/null 2>&1 && echo true || echo false)"
        echo "git_installed=$(command -v git >/dev/null 2>&1 && echo true || echo false)"
        echo "node_installed=$(command -v node >/dev/null 2>&1 && echo true || echo false)"
        echo "python3_installed=$(command -v python3 >/dev/null 2>&1 && echo true || echo false)"
    } > "$checkpoint_path/state/applications.txt"
    
    # Record which dotfiles are currently symlinked
    find "$HOME" -maxdepth 1 -type l -ls 2>/dev/null | grep -E "\.(zshrc|gitconfig|vimrc)" > "$checkpoint_path/state/dotfile_symlinks.txt" || true
}

backup_essential_configs() {
    local checkpoint_path="$1"
    local quick_mode="$2"
    
    log "Backing up essential configurations..."
    
    # Always backup critical config files
    local critical_files=(
        ".zshrc"
        ".zpreztorc" 
        ".gitconfig"
        ".gitignore_global"
        ".vimrc"
        ".ssh/config"
    )
    
    for file in "${critical_files[@]}"; do
        if [ -f "$HOME/$file" ]; then
            local dir=$(dirname "$file")
            mkdir -p "$checkpoint_path/configs/$dir"
            cp "$HOME/$file" "$checkpoint_path/configs/$file"
        fi
    done
    
    # Quick mode: skip application-specific configs
    if [ "$quick_mode" = "true" ]; then
        return 0
    fi
    
    # Backup VS Code settings
    if [ -d "$HOME/Library/Application Support/Code/User" ]; then
        mkdir -p "$checkpoint_path/configs/vscode"
        cp "$HOME/Library/Application Support/Code/User/settings.json" "$checkpoint_path/configs/vscode/" 2>/dev/null || true
        cp "$HOME/Library/Application Support/Code/User/keybindings.json" "$checkpoint_path/configs/vscode/" 2>/dev/null || true
    fi
    
    # Backup Terminal configuration  
    if [ -d "$HOME/.config/alacritty" ]; then
        cp -r "$HOME/.config/alacritty" "$checkpoint_path/configs/"
    fi
    
    # Backup mise/asdf configuration
    [ -f "$HOME/.tool-versions" ] && cp "$HOME/.tool-versions" "$checkpoint_path/configs/"
    [ -d "$HOME/.config/mise" ] && cp -r "$HOME/.config/mise" "$checkpoint_path/configs/"
    
    success "Essential configurations backed up"
}

backup_package_states() {
    local checkpoint_path="$1"
    
    log "Capturing package states..."
    
    # Homebrew packages
    if command -v brew >/dev/null 2>&1; then
        brew list > "$checkpoint_path/packages/homebrew_packages.txt" 2>/dev/null || true
        brew list --cask > "$checkpoint_path/packages/homebrew_casks.txt" 2>/dev/null || true
        brew tap > "$checkpoint_path/packages/homebrew_taps.txt" 2>/dev/null || true
    fi
    
    # Python packages
    if command -v pip >/dev/null 2>&1; then
        pip list --freeze > "$checkpoint_path/packages/pip_packages.txt" 2>/dev/null || true
    fi
    
    # Node.js packages
    if command -v npm >/dev/null 2>&1; then
        npm list -g --depth=0 > "$checkpoint_path/packages/npm_packages.txt" 2>/dev/null || true
    fi
    
    # VS Code extensions
    if command -v code >/dev/null 2>&1; then
        code --list-extensions > "$checkpoint_path/packages/vscode_extensions.txt" 2>/dev/null || true
    fi
    
    success "Package states captured"
}

backup_system_preferences() {
    local checkpoint_path="$1"
    
    log "Backing up system preferences..."
    
    mkdir -p "$checkpoint_path/configs/system"
    
    # Essential system preferences
    local domains=(
        "com.apple.dock"
        "com.apple.finder"
        "com.apple.Safari"
        "com.apple.systempreferences"
        "com.apple.Terminal"
        "NSGlobalDomain"
    )
    
    for domain in "${domains[@]}"; do
        defaults export "$domain" "$checkpoint_path/configs/system/${domain}.plist" 2>/dev/null || true
    done
    
    success "System preferences backed up"
}

create_recovery_script() {
    local checkpoint_path="$1"
    local checkpoint_name="$2"
    
    cat > "$checkpoint_path/recover.sh" << 'EOF'
#!/bin/bash
# Auto-generated recovery script for checkpoint: $checkpoint_name

set -euo pipefail

CHECKPOINT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CHECKPOINT_NAME="$checkpoint_name"

echo "üîÑ Recovering from checkpoint: $CHECKPOINT_NAME"
echo "üìÅ Checkpoint location: $CHECKPOINT_DIR"
echo

# Function to restore a file with backup
restore_file() {
    local src="$1"
    local dest="$2"
    
    if [ -f "$src" ]; then
        # Backup current file if it exists
        if [ -f "$dest" ]; then
            cp "$dest" "${dest}.pre-restore-$(date +%s)" 2>/dev/null || true
        fi
        
        # Create directory if needed
        mkdir -p "$(dirname "$dest")"
        
        # Restore file
        cp "$src" "$dest"
        echo "‚úÖ Restored: $dest"
    fi
}

# Restore critical configuration files
if [ -d "$CHECKPOINT_DIR/configs" ]; then
    echo "üîß Restoring configuration files..."
    
    # Restore dotfiles
    for config in .zshrc .zpreztorc .gitconfig .gitignore_global .vimrc; do
        restore_file "$CHECKPOINT_DIR/configs/$config" "$HOME/$config"
    done
    
    # Restore SSH config
    if [ -f "$CHECKPOINT_DIR/configs/.ssh/config" ]; then
        mkdir -p "$HOME/.ssh"
        restore_file "$CHECKPOINT_DIR/configs/.ssh/config" "$HOME/.ssh/config"
        chmod 600 "$HOME/.ssh/config"
    fi
    
    # Restore VS Code settings
    if [ -f "$CHECKPOINT_DIR/configs/vscode/settings.json" ]; then
        local vscode_dir="$HOME/Library/Application Support/Code/User"
        mkdir -p "$vscode_dir"
        restore_file "$CHECKPOINT_DIR/configs/vscode/settings.json" "$vscode_dir/settings.json"
        restore_file "$CHECKPOINT_DIR/configs/vscode/keybindings.json" "$vscode_dir/keybindings.json"
    fi
    
    # Restore Terminal configuration
    if [ -d "$CHECKPOINT_DIR/configs/alacritty" ]; then
        mkdir -p "$HOME/.config"
        cp -r "$CHECKPOINT_DIR/configs/alacritty" "$HOME/.config/"
        echo "‚úÖ Restored: Alacritty configuration"
    fi
    
    # Restore tool versions
    restore_file "$CHECKPOINT_DIR/configs/.tool-versions" "$HOME/.tool-versions"
    
    if [ -d "$CHECKPOINT_DIR/configs/mise" ]; then
        mkdir -p "$HOME/.config"
        cp -r "$CHECKPOINT_DIR/configs/mise" "$HOME/.config/"
        echo "‚úÖ Restored: mise configuration"
    fi
fi

# Restore system preferences
if [ -d "$CHECKPOINT_DIR/configs/system" ]; then
    echo "üñ•Ô∏è  Restoring system preferences..."
    
    for plist in "$CHECKPOINT_DIR/configs/system"/*.plist; do
        if [ -f "$plist" ]; then
            local domain=$(basename "$plist" .plist)
            defaults import "$domain" "$plist" 2>/dev/null || true
            echo "‚úÖ Restored preferences: $domain"
        fi
    done
fi

echo
echo "üéâ Recovery completed!"
echo "üí° Note: Some changes may require a restart or re-login to take effect"
echo "üìù Original files were backed up with .pre-restore-timestamp suffix"

# Show bootstrap state information
if [ -f "$CHECKPOINT_DIR/metadata/checkpoint.json" ]; then
    echo
    echo "üìä Checkpoint Information:"
    grep -E '"(name|description|created_at|bootstrap_phase)"' "$CHECKPOINT_DIR/metadata/checkpoint.json" | sed 's/^/  /'
fi
EOF
    
    chmod +x "$checkpoint_path/recover.sh"
}

restore_checkpoint() {
    local checkpoint_name="$1"
    local dry_run="$2"
    local force="$3"
    
    # Find checkpoint
    local checkpoint_path=$(find_checkpoint "$checkpoint_name")
    if [ -z "$checkpoint_path" ]; then
        error "Checkpoint '$checkpoint_name' not found"
    fi
    
    log "Restoring from checkpoint: $checkpoint_path"
    
    if [ "$dry_run" = "true" ]; then
        log "Would restore checkpoint: $checkpoint_name"
        if [ -f "$checkpoint_path/metadata/checkpoint.json" ]; then
            echo "Checkpoint metadata:"
            cat "$checkpoint_path/metadata/checkpoint.json"
        fi
        return 0
    fi
    
    # Confirm unless forced
    if [ "$force" = "false" ]; then
        echo -e "\n${YELLOW}WARNING: This will overwrite current configurations!${NC}"
        read -p "Continue with checkpoint restore? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Restore cancelled"
            exit 0
        fi
    fi
    
    # Run the recovery script
    if [ -f "$checkpoint_path/recover.sh" ]; then
        bash "$checkpoint_path/recover.sh"
        success "Checkpoint restored successfully"
    else
        error "Recovery script not found in checkpoint"
    fi
}

list_checkpoints() {
    if [ ! -d "$CHECKPOINT_DIR" ]; then
        warning "No checkpoints directory found"
        return
    fi
    
    log "Available checkpoints:"
    echo
    
    find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | while read -r checkpoint; do
        local checkpoint_name=$(basename "$checkpoint")
        local checkpoint_date=""
        
        if [ -f "$checkpoint/metadata/checkpoint.json" ]; then
            local name=$(grep '"name"' "$checkpoint/metadata/checkpoint.json" | cut -d'"' -f4)
            local description=$(grep '"description"' "$checkpoint/metadata/checkpoint.json" | cut -d'"' -f4)
            local created_at=$(grep '"created_at"' "$checkpoint/metadata/checkpoint.json" | cut -d'"' -f4)
            local phase=$(grep '"bootstrap_phase"' "$checkpoint/metadata/checkpoint.json" | cut -d'"' -f4)
            
            printf "  %-30s %s\n" "$name" "$created_at"
            [ -n "$description" ] && printf "    üìù %s\n" "$description"
            [ "$phase" != "unknown" ] && printf "    üîß Phase: %s\n" "$phase"
            echo
        else
            printf "  %-30s %s\n" "$checkpoint_name" "$(date -r "$checkpoint" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo 'Unknown')"
        fi
    done
    
    # Show latest checkpoint
    if [ -L "$CHECKPOINT_DIR/latest" ]; then
        local latest=$(readlink "$CHECKPOINT_DIR/latest")
        echo -e "${GREEN}Latest checkpoint: $latest${NC}"
    fi
}

delete_checkpoint() {
    local checkpoint_name="$1"
    local force="$2"
    
    local checkpoint_path=$(find_checkpoint "$checkpoint_name")
    if [ -z "$checkpoint_path" ]; then
        error "Checkpoint '$checkpoint_name' not found"
    fi
    
    if [ "$force" = "false" ]; then
        read -p "Delete checkpoint '$checkpoint_name'? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Deletion cancelled"
            exit 0
        fi
    fi
    
    rm -rf "$checkpoint_path"
    success "Checkpoint deleted: $checkpoint_name"
    
    # Update latest symlink if needed
    if [ -L "$CHECKPOINT_DIR/latest" ] && [ "$(readlink "$CHECKPOINT_DIR/latest")" = "$(basename "$checkpoint_path")" ]; then
        rm -f "$CHECKPOINT_DIR/latest"
        # Point to most recent remaining checkpoint
        local newest=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -1)
        if [ -n "$newest" ]; then
            ln -sf "$(basename "$newest")" "$CHECKPOINT_DIR/latest"
        fi
    fi
}

find_checkpoint() {
    local checkpoint_name="$1"
    
    # Try exact match first
    local exact_match=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "${checkpoint_name}_*" | head -1)
    if [ -n "$exact_match" ]; then
        echo "$exact_match"
        return 0
    fi
    
    # Try latest if requested
    if [ "$checkpoint_name" = "latest" ] && [ -L "$CHECKPOINT_DIR/latest" ]; then
        echo "$CHECKPOINT_DIR/$(readlink "$CHECKPOINT_DIR/latest")"
        return 0
    fi
    
    # Try partial match
    local partial_match=$(find "$CHECKPOINT_DIR" -maxdepth 1 -type d -name "*${checkpoint_name}*" | head -1)
    if [ -n "$partial_match" ]; then
        echo "$partial_match"
        return 0
    fi
    
    return 1
}

auto_checkpoint() {
    local phase="$1"
    local description="Bootstrap checkpoint: $phase"
    
    export BOOTSTRAP_PHASE="$phase"
    
    case "$phase" in
        pre-ansible)
            description="Before running Ansible automation"
            create_checkpoint "pre-ansible" "$description" "true" "false" "false"
            ;;
        pre-homebrew)
            description="Before installing Homebrew packages"
            create_checkpoint "pre-homebrew" "$description" "false" "true" "false"
            ;;
        pre-dotfiles)
            description="Before installing dotfiles"
            create_checkpoint "pre-dotfiles" "$description" "false" "true" "false"
            ;;
        pre-applications)
            description="Before installing applications"
            create_checkpoint "pre-applications" "$description" "false" "true" "false"
            ;;
        post-setup)
            description="After complete setup"
            create_checkpoint "post-setup" "$description" "true" "false" "false"
            ;;
        *)
            error "Unknown bootstrap phase: $phase"
            ;;
    esac
}

# Main execution
main() {
    local command=""
    local checkpoint_name=""
    local description=""
    local force=false
    local dry_run=false
    local include_system=false
    local quick_mode=false
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            create|restore|list|delete|auto)
                command="$1"
                shift
                ;;
            --description)
                description="$2"
                shift 2
                ;;
            --force)
                force=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --include-system)
                include_system=true
                shift
                ;;
            --quick)
                quick_mode=true
                shift
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                if [ -z "$checkpoint_name" ]; then
                    checkpoint_name="$1"
                    shift
                else
                    error "Unknown option: $1"
                fi
                ;;
        esac
    done
    
    # Validate command
    if [ -z "$command" ]; then
        show_usage
        exit 1
    fi
    
    # Create checkpoint directory
    mkdir -p "$CHECKPOINT_DIR"
    mkdir -p "$(dirname "$LOGFILE")"
    
    # Execute command
    case "$command" in
        create)
            [ -z "$checkpoint_name" ] && error "Checkpoint name required for create command"
            create_checkpoint "$checkpoint_name" "$description" "$include_system" "$quick_mode" "$dry_run"
            ;;
        restore)
            [ -z "$checkpoint_name" ] && error "Checkpoint name required for restore command"
            restore_checkpoint "$checkpoint_name" "$dry_run" "$force"
            ;;
        list)
            list_checkpoints
            ;;
        delete)
            [ -z "$checkpoint_name" ] && error "Checkpoint name required for delete command"
            delete_checkpoint "$checkpoint_name" "$force"
            ;;
        auto)
            [ -z "$checkpoint_name" ] && error "Bootstrap phase required for auto command"
            auto_checkpoint "$checkpoint_name"
            ;;
        *)
            error "Unknown command: $command"
            ;;
    esac
}

# Run main function
main "$@"