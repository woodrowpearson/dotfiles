#!/bin/bash
# Comprehensive Backup Restoration Script
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

# Configuration
BACKUP_LOCAL_DIR="{{ backup_local_dir }}"
BACKUP_BASE_DIR="{{ backup_base_dir }}"
ENCRYPTION_ENABLED={{ backup_encryption.enabled | lower }}
TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
LOGFILE="$BACKUP_LOCAL_DIR/logs/restore_$TIMESTAMP.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOGFILE"
}

success() {
    echo -e "${GREEN}✅ $1${NC}" | tee -a "$LOGFILE"
}

warning() {
    echo -e "${YELLOW}⚠️  $1${NC}" | tee -a "$LOGFILE"
}

error() {
    echo -e "${RED}❌ $1${NC}" | tee -a "$LOGFILE"
    exit 1
}

show_usage() {
    cat << EOF
Usage: backup-restore [OPTIONS] BACKUP_NAME

OPTIONS:
    --configs              Restore application configurations only
    --security             Restore security items (SSH, GPG keys)
    --development          Restore development environment
    --system               Restore macOS preferences
    --selective APP        Restore specific application (vscode, git, ssh, etc.)
    --interactive          Interactive mode for selecting what to restore
    --dry-run              Show what would be restored without applying changes
    --force                Skip confirmation prompts
    --from-external        Restore from external drive backup
    --decrypt              Decrypt encrypted security data
    --backup-current       Create backup of current configs before restoring
    --help                 Show this help message

EXAMPLES:
    backup-restore --configs pre-setup_20240125_143022       # Restore all configs
    backup-restore --selective vscode full_20240125_143022   # Restore VS Code only
    backup-restore --security --decrypt full_20240125_143022 # Restore SSH/GPG keys
    backup-restore --interactive full_20240125_143022        # Interactive selection
    backup-restore --dry-run full_20240125_143022            # Preview changes

BACKUP_NAME:
    Use the name of an existing backup (without timestamp suffix)
    Or use 'latest' to restore from the most recent backup
EOF
}

list_available_backups() {
    log "Available backups:"
    
    # List local backups
    if [ -d "$BACKUP_LOCAL_DIR" ]; then
        echo -e "\n${BLUE}Local backups:${NC}"
        find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -10 | while read -r backup; do
            local backup_name=$(basename "$backup")
            local backup_date=$(date -r "$backup" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "Unknown")
            printf "  %-30s %s\n" "$backup_name" "$backup_date"
        done
    fi
    
    # List external backups if available
    if [ -d "$BACKUP_BASE_DIR" ]; then
        echo -e "\n${BLUE}External backups:${NC}"
        find "$BACKUP_BASE_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -10 | while read -r backup; do
            local backup_name=$(basename "$backup")
            local backup_date=$(date -r "$backup" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "Unknown")
            printf "  %-30s %s\n" "$backup_name" "$backup_date"
        done
    fi
}

find_backup_path() {
    local backup_name="$1"
    local from_external="$2"
    
    if [ "$backup_name" = "latest" ]; then
        if [ "$from_external" = "true" ] && [ -d "$BACKUP_BASE_DIR" ]; then
            backup_name=$(find "$BACKUP_BASE_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -1 | xargs basename 2>/dev/null || echo "")
            if [ -n "$backup_name" ]; then
                echo "$BACKUP_BASE_DIR/$backup_name"
                return 0
            fi
        fi
        backup_name=$(find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -1 | xargs basename 2>/dev/null || echo "")
        if [ -n "$backup_name" ]; then
            echo "$BACKUP_LOCAL_DIR/$backup_name"
            return 0
        fi
        error "No backups found"
    fi
    
    # Try external first if requested
    if [ "$from_external" = "true" ]; then
        if [ -d "$BACKUP_BASE_DIR/$backup_name" ]; then
            echo "$BACKUP_BASE_DIR/$backup_name"
            return 0
        fi
    fi
    
    # Try local backup
    if [ -d "$BACKUP_LOCAL_DIR/$backup_name" ]; then
        echo "$BACKUP_LOCAL_DIR/$backup_name"
        return 0
    fi
    
    error "Backup '$backup_name' not found"
}

create_current_backup() {
    if command -v backup-create >/dev/null 2>&1; then
        log "Creating backup of current configuration..."
        backup-create --config-only --name "pre-restore" --quiet
        success "Current configuration backed up"
    else
        warning "backup-create not found, skipping current config backup"
    fi
}

decrypt_security_data() {
    local backup_dir="$1"
    
    if [ -f "$backup_dir/security.tar.gz.gpg" ]; then
        log "Decrypting security data..."
        if gpg --decrypt "$backup_dir/security.tar.gz.gpg" | tar -xzf - -C "$backup_dir"; then
            success "Security data decrypted"
        else
            error "Failed to decrypt security data"
        fi
    fi
}

restore_application_configs() {
    local backup_dir="$1"
    local app_filter="$2"
    local dry_run="$3"
    
    if [ ! -d "$backup_dir/configs" ]; then
        warning "No application configs found in backup"
        return
    fi
    
    log "Restoring application configurations..."
    
    {% if backup_applications.vscode.enabled %}
    if [[ "$app_filter" == "all" || "$app_filter" == "vscode" ]]; then
        if [ -d "$backup_dir/configs/vscode" ]; then
            log "Restoring VS Code configuration..."
            local vscode_user_dir="$HOME/Library/Application Support/Code/User"
            
            if [ "$dry_run" = "false" ]; then
                mkdir -p "$vscode_user_dir"
                [ -f "$backup_dir/configs/vscode/settings.json" ] && cp "$backup_dir/configs/vscode/settings.json" "$vscode_user_dir/"
                [ -f "$backup_dir/configs/vscode/keybindings.json" ] && cp "$backup_dir/configs/vscode/keybindings.json" "$vscode_user_dir/"
                [ -d "$backup_dir/configs/vscode/snippets" ] && cp -r "$backup_dir/configs/vscode/snippets" "$vscode_user_dir/"
                
                # Restore extensions
                if [ -f "$backup_dir/configs/vscode/extensions.list" ]; then
                    while read -r extension; do
                        [ -n "$extension" ] && code --install-extension "$extension" >/dev/null 2>&1 || true
                    done < "$backup_dir/configs/vscode/extensions.list"
                fi
                success "VS Code configuration restored"
            else
                echo "  Would restore VS Code settings, keybindings, snippets, and extensions"
            fi
        fi
    fi
    {% endif %}
    
    {% if backup_applications.terminal.enabled %}
    if [[ "$app_filter" == "all" || "$app_filter" == "terminal" ]]; then
        if [ -d "$backup_dir/configs/terminal" ]; then
            log "Restoring terminal configuration..."
            
            if [ "$dry_run" = "false" ]; then
                [ -d "$backup_dir/configs/terminal/alacritty" ] && cp -r "$backup_dir/configs/terminal/alacritty" "$HOME/.config/"
                [ -f "$backup_dir/configs/terminal/.zshrc" ] && cp "$backup_dir/configs/terminal/.zshrc" "$HOME/"
                [ -f "$backup_dir/configs/terminal/.zpreztorc" ] && cp "$backup_dir/configs/terminal/.zpreztorc" "$HOME/"
                success "Terminal configuration restored"
            else
                echo "  Would restore terminal configurations (.zshrc, .zpreztorc, alacritty)"
            fi
        fi
    fi
    {% endif %}
    
    {% if backup_applications.git.enabled %}
    if [[ "$app_filter" == "all" || "$app_filter" == "git" ]]; then
        if [ -d "$backup_dir/configs/git" ]; then
            log "Restoring Git configuration..."
            
            if [ "$dry_run" = "false" ]; then
                [ -f "$backup_dir/configs/git/.gitconfig" ] && cp "$backup_dir/configs/git/.gitconfig" "$HOME/"
                [ -f "$backup_dir/configs/git/.gitignore_global" ] && cp "$backup_dir/configs/git/.gitignore_global" "$HOME/"
                success "Git configuration restored"
            else
                echo "  Would restore Git configuration (.gitconfig, .gitignore_global)"
            fi
        fi
    fi
    {% endif %}
    
    {% if backup_applications.homebrew.enabled %}
    if [[ "$app_filter" == "all" || "$app_filter" == "homebrew" ]]; then
        if [ -d "$backup_dir/configs/homebrew" ]; then
            log "Restoring Homebrew packages..."
            
            if [ "$dry_run" = "false" ]; then
                # Install packages
                if [ -f "$backup_dir/configs/homebrew/packages.list" ]; then
                    while read -r package; do
                        [ -n "$package" ] && brew install "$package" >/dev/null 2>&1 || true
                    done < "$backup_dir/configs/homebrew/packages.list"
                fi
                
                # Install casks
                if [ -f "$backup_dir/configs/homebrew/casks.list" ]; then
                    while read -r cask; do
                        [ -n "$cask" ] && brew install --cask "$cask" >/dev/null 2>&1 || true
                    done < "$backup_dir/configs/homebrew/casks.list"
                fi
                
                # Add taps
                if [ -f "$backup_dir/configs/homebrew/taps.list" ]; then
                    while read -r tap; do
                        [ -n "$tap" ] && brew tap "$tap" >/dev/null 2>&1 || true
                    done < "$backup_dir/configs/homebrew/taps.list"
                fi
                
                success "Homebrew packages restored"
            else
                echo "  Would restore Homebrew packages, casks, and taps"
            fi
        fi
    fi
    {% endif %}
    
    # Restore mackup applications
    {% if backup_components.applications %}
    if [[ "$app_filter" == "all" || "$app_filter" == "mackup" ]]; then
        if [ -d "$backup_dir/configs/mackup" ] && command -v mackup >/dev/null 2>&1; then
            log "Restoring applications via mackup..."
            
            if [ "$dry_run" = "false" ]; then
                # Temporarily override mackup config
                echo "[storage]" > /tmp/mackup_temp.cfg
                echo "engine = file_system" >> /tmp/mackup_temp.cfg
                echo "path = $backup_dir/configs/mackup" >> /tmp/mackup_temp.cfg
                
                MACKUP_CONFIG_FILE=/tmp/mackup_temp.cfg mackup restore --force >/dev/null 2>&1 || true
                rm -f /tmp/mackup_temp.cfg
                success "Applications restored via mackup"
            else
                echo "  Would restore additional applications via mackup"
            fi
        fi
    fi
    {% endif %}
}

restore_security_items() {
    local backup_dir="$1"
    local app_filter="$2"
    local dry_run="$3"
    local decrypt="$4"
    
    if [ "$decrypt" = "true" ]; then
        decrypt_security_data "$backup_dir"
    fi
    
    if [ ! -d "$backup_dir/security" ]; then
        warning "No security items found in backup"
        return
    fi
    
    log "Restoring security items..."
    
    {% if backup_applications.ssh.enabled %}
    if [[ "$app_filter" == "all" || "$app_filter" == "ssh" ]]; then
        if [ -d "$backup_dir/security/ssh" ]; then
            log "Restoring SSH configuration..."
            
            if [ "$dry_run" = "false" ]; then
                mkdir -p "$HOME/.ssh"
                chmod 700 "$HOME/.ssh"
                
                [ -f "$backup_dir/security/ssh/config" ] && cp "$backup_dir/security/ssh/config" "$HOME/.ssh/"
                [ -f "$backup_dir/security/ssh/known_hosts" ] && cp "$backup_dir/security/ssh/known_hosts" "$HOME/.ssh/"
                
                # Restore public keys
                cp "$backup_dir/security/ssh"/*.pub "$HOME/.ssh/" 2>/dev/null || true
                
                {% if backup_applications.ssh.private_keys %}
                # Restore encrypted private keys
                for encrypted_key in "$backup_dir/security/ssh"/*.gpg; do
                    if [ -f "$encrypted_key" ]; then
                        local key_name=$(basename "$encrypted_key" .gpg)
                        if gpg --decrypt "$encrypted_key" > "$HOME/.ssh/$key_name" 2>/dev/null; then
                            chmod 600 "$HOME/.ssh/$key_name"
                        fi
                    fi
                done
                {% endif %}
                
                success "SSH configuration restored"
            else
                echo "  Would restore SSH configuration and keys"
            fi
        fi
    fi
    {% endif %}
    
    # Restore GPG keys
    if [[ "$app_filter" == "all" || "$app_filter" == "gpg" ]]; then
        if [ -f "$backup_dir/security/gpg_public_keys.asc" ]; then
            log "Restoring GPG keys..."
            
            if [ "$dry_run" = "false" ]; then
                gpg --import "$backup_dir/security/gpg_public_keys.asc" >/dev/null 2>&1 || true
                [ -f "$backup_dir/security/gpg_private_keys.asc" ] && gpg --import "$backup_dir/security/gpg_private_keys.asc" >/dev/null 2>&1 || true
                success "GPG keys restored"
            else
                echo "  Would restore GPG public and private keys"
            fi
        fi
    fi
}

restore_development_environment() {
    local backup_dir="$1"
    local app_filter="$2"
    local dry_run="$3"
    
    if [ ! -d "$backup_dir/development" ]; then
        warning "No development environment found in backup"
        return
    fi
    
    log "Restoring development environment..."
    
    {% if backup_development.languages.python.enabled %}
    if [[ "$app_filter" == "all" || "$app_filter" == "python" ]]; then
        if [ -f "$backup_dir/development/python_packages.txt" ]; then
            log "Restoring Python packages..."
            
            if [ "$dry_run" = "false" ]; then
                pip install -r "$backup_dir/development/python_packages.txt" >/dev/null 2>&1 || true
                [ -f "$backup_dir/development/.pypirc" ] && cp "$backup_dir/development/.pypirc" "$HOME/"
                success "Python environment restored"
            else
                echo "  Would restore Python packages and .pypirc"
            fi
        fi
    fi
    {% endif %}
    
    {% if backup_development.languages.node.enabled %}
    if [[ "$app_filter" == "all" || "$app_filter" == "node" ]]; then
        if [ -f "$backup_dir/development/npm_global_packages.txt" ]; then
            log "Restoring Node.js packages..."
            
            if [ "$dry_run" = "false" ]; then
                # Parse npm list output and install packages
                grep -E '^├──|^└──' "$backup_dir/development/npm_global_packages.txt" | \
                sed 's/^[├└]── //' | sed 's/@.*$//' | while read -r package; do
                    [ -n "$package" ] && npm install -g "$package" >/dev/null 2>&1 || true
                done
                [ -f "$backup_dir/development/.npmrc" ] && cp "$backup_dir/development/.npmrc" "$HOME/"
                success "Node.js environment restored"
            else
                echo "  Would restore Node.js global packages and .npmrc"
            fi
        fi
    fi
    {% endif %}
    
    {% if backup_development.languages.rust.enabled %}
    if [[ "$app_filter" == "all" || "$app_filter" == "rust" ]]; then
        if [ -f "$backup_dir/development/cargo_packages.txt" ]; then
            log "Restoring Rust packages..."
            
            if [ "$dry_run" = "false" ]; then
                # Parse cargo install list and install packages
                grep -v '^$' "$backup_dir/development/cargo_packages.txt" | while read -r line; do
                    local package=$(echo "$line" | awk '{print $1}')
                    [ -n "$package" ] && cargo install "$package" >/dev/null 2>&1 || true
                done
                [ -f "$backup_dir/development/config.toml" ] && mkdir -p "$HOME/.cargo" && cp "$backup_dir/development/config.toml" "$HOME/.cargo/"
                success "Rust environment restored"
            else
                echo "  Would restore Rust packages and cargo config"
            fi
        fi
    fi
    {% endif %}
    
    {% if backup_development.tools.mise.enabled %}
    if [[ "$app_filter" == "all" || "$app_filter" == "mise" ]]; then
        if [ -d "$backup_dir/development/mise" ]; then
            log "Restoring mise configuration..."
            
            if [ "$dry_run" = "false" ]; then
                mkdir -p "$HOME/.config"
                cp -r "$backup_dir/development/mise" "$HOME/.config/"
                [ -f "$backup_dir/development/.tool-versions" ] && cp "$backup_dir/development/.tool-versions" "$HOME/"
                success "mise configuration restored"
            else
                echo "  Would restore mise configuration and .tool-versions"
            fi
        fi
    fi
    {% endif %}
}

restore_macos_preferences() {
    local backup_dir="$1"
    local dry_run="$2"
    
    if [ ! -d "$backup_dir/system/preferences" ]; then
        warning "No macOS preferences found in backup"
        return
    fi
    
    log "Restoring macOS preferences..."
    
    if [ "$dry_run" = "false" ]; then
        {% for domain in backup_applications.macos.domains %}
        if [ -f "$backup_dir/system/preferences/{{ domain }}.plist" ]; then
            defaults import {{ domain }} "$backup_dir/system/preferences/{{ domain }}.plist" 2>/dev/null || true
        fi
        {% endfor %}
        success "macOS preferences restored"
    else
        echo "  Would restore macOS system preferences"
        ls -1 "$backup_dir/system/preferences"/*.plist 2>/dev/null | while read -r plist; do
            local domain=$(basename "$plist" .plist)
            echo "    - $domain"
        done
    fi
}

interactive_restore() {
    local backup_dir="$1"
    
    echo -e "\n${BLUE}Interactive Restore Mode${NC}"
    echo "Select what to restore from backup: $(basename "$backup_dir")"
    echo
    
    local restore_configs=false
    local restore_security=false
    local restore_development=false
    local restore_system=false
    local decrypt_security=false
    
    # Check what's available
    [ -d "$backup_dir/configs" ] && restore_configs=$(ask_yes_no "Restore application configurations?")
    [ -d "$backup_dir/security" ] || [ -f "$backup_dir/security.tar.gz.gpg" ] && {
        restore_security=$(ask_yes_no "Restore security items (SSH, GPG)?")
        [ "$restore_security" = "true" ] && [ -f "$backup_dir/security.tar.gz.gpg" ] && decrypt_security=$(ask_yes_no "Decrypt security data?")
    }
    [ -d "$backup_dir/development" ] && restore_development=$(ask_yes_no "Restore development environment?")
    [ -d "$backup_dir/system" ] && restore_system=$(ask_yes_no "Restore macOS preferences?")
    
    echo
    
    # Perform selected restores
    [ "$restore_configs" = "true" ] && restore_application_configs "$backup_dir" "all" "false"
    [ "$restore_security" = "true" ] && restore_security_items "$backup_dir" "all" "false" "$decrypt_security"
    [ "$restore_development" = "true" ] && restore_development_environment "$backup_dir" "all" "false"
    [ "$restore_system" = "true" ] && restore_macos_preferences "$backup_dir" "false"
}

ask_yes_no() {
    local prompt="$1"
    while true; do
        read -p "$prompt (y/N): " yn
        case $yn in
            [Yy]* ) echo "true"; return;;
            [Nn]* | "" ) echo "false"; return;;
            * ) echo "Please answer yes or no.";;
        esac
    done
}

# Main execution
main() {
    local restore_configs=false
    local restore_security=false
    local restore_development=false
    local restore_system=false
    local selective_app=""
    local interactive=false
    local dry_run=false
    local force=false
    local from_external=false
    local decrypt=false
    local backup_current=true
    local backup_name=""
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --configs)
                restore_configs=true
                shift
                ;;
            --security)
                restore_security=true
                shift
                ;;
            --development)
                restore_development=true
                shift
                ;;
            --system)
                restore_system=true
                shift
                ;;
            --selective)
                selective_app="$2"
                shift 2
                ;;
            --interactive)
                interactive=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            --from-external)
                from_external=true
                shift
                ;;
            --decrypt)
                decrypt=true
                shift
                ;;
            --backup-current)
                backup_current=true
                shift
                ;;
            --no-backup-current)
                backup_current=false
                shift
                ;;
            --list)
                list_available_backups
                exit 0
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                if [ -z "$backup_name" ]; then
                    backup_name="$1"
                    shift
                else
                    error "Unknown option: $1"
                fi
                ;;
        esac
    done
    
    # Validate arguments
    if [ -z "$backup_name" ]; then
        echo "Available backups:"
        list_available_backups
        echo
        error "Please specify a backup name"
    fi
    
    # Find backup path
    local backup_dir=$(find_backup_path "$backup_name" "$from_external")
    
    log "Restoring from backup: $backup_dir"
    
    # Confirm unless forced or dry run
    if [ "$force" = "false" ] && [ "$dry_run" = "false" ]; then
        echo -e "\n${YELLOW}WARNING: This will overwrite current configurations!${NC}"
        if ! ask_yes_no "Continue with restore?"; then
            echo "Restore cancelled"
            exit 0
        fi
    fi
    
    # Create backup of current state
    if [ "$backup_current" = "true" ] && [ "$dry_run" = "false" ]; then
        create_current_backup
    fi
    
    # Set restore mode
    if [ "$interactive" = "true" ]; then
        interactive_restore "$backup_dir"
    elif [ -n "$selective_app" ]; then
        restore_application_configs "$backup_dir" "$selective_app" "$dry_run"
        restore_security_items "$backup_dir" "$selective_app" "$dry_run" "$decrypt"
        restore_development_environment "$backup_dir" "$selective_app" "$dry_run"
    elif [ "$restore_configs" = "true" ] || [ "$restore_security" = "true" ] || [ "$restore_development" = "true" ] || [ "$restore_system" = "true" ]; then
        [ "$restore_configs" = "true" ] && restore_application_configs "$backup_dir" "all" "$dry_run"
        [ "$restore_security" = "true" ] && restore_security_items "$backup_dir" "all" "$dry_run" "$decrypt"
        [ "$restore_development" = "true" ] && restore_development_environment "$backup_dir" "all" "$dry_run"
        [ "$restore_system" = "true" ] && restore_macos_preferences "$backup_dir" "$dry_run"
    else
        # Default: restore everything
        restore_application_configs "$backup_dir" "all" "$dry_run"
        restore_security_items "$backup_dir" "all" "$dry_run" "$decrypt"
        restore_development_environment "$backup_dir" "all" "$dry_run"
        restore_macos_preferences "$backup_dir" "$dry_run"
    fi
    
    if [ "$dry_run" = "true" ]; then
        log "Dry run completed - no changes were made"
    else
        success "Restore completed successfully"
        log "Backup restored from: $backup_dir"
    fi
}

# Ensure script directory exists
mkdir -p "$(dirname "$LOGFILE")"

# Run main function
main "$@"