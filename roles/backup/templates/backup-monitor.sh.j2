#!/bin/bash
# Backup Monitoring and Health Check Script
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

# Configuration
BACKUP_LOCAL_DIR="{{ backup_local_dir }}"
BACKUP_BASE_DIR="{{ backup_base_dir }}"
MAX_AGE_DAYS={{ backup_retention_days }}
NOTIFICATION_ENABLED="{{ backup_monitoring.notifications | default(false) | lower }}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
}

success() {
    echo -e "${GREEN}✅ $1${NC}"
}

warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

error() {
    echo -e "${RED}❌ $1${NC}"
}

check_backup_health() {
    local issues=0
    
    log "Checking backup system health..."
    
    # Check if backup directories exist
    if [ ! -d "$BACKUP_LOCAL_DIR" ]; then
        error "Local backup directory missing: $BACKUP_LOCAL_DIR"
        ((issues++))
    else
        success "Local backup directory exists"
    fi
    
    # Check for recent backups
    local latest_backup=$(find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -1)
    if [ -n "$latest_backup" ]; then
        local backup_age=$(( ($(date +%s) - $(date -r "$latest_backup" +%s)) / 86400 ))
        if [ "$backup_age" -gt 7 ]; then
            warning "Latest backup is $backup_age days old ($(basename "$latest_backup"))"
            ((issues++))
        else
            success "Recent backup found: $(basename "$latest_backup") ($backup_age days ago)"
        fi
    else
        error "No backups found"
        ((issues++))
    fi
    
    # Check external drive availability
    if [ -d "$(dirname "$BACKUP_BASE_DIR")" ]; then
        success "External backup drive connected"
    else
        warning "External backup drive not connected"
    fi
    
    # Check backup scripts
    local scripts=("backup-create" "backup-restore" "backup-checkpoint" "backup-list" "backup-rollback")
    for script in "${scripts[@]}"; do
        if [ -x "$HOME/.local/bin/$script" ]; then
            success "Script available: $script"
        else
            error "Script missing or not executable: $script"
            ((issues++))
        fi
    done
    
    # Check GPG key for encryption
    {% if backup_encryption.enabled %}
    if gpg --list-secret-keys "dotfiles-backup" >/dev/null 2>&1; then
        success "Backup encryption key available"
    else
        error "Backup encryption key missing"
        ((issues++))
    fi
    {% endif %}
    
    # Summary
    echo
    if [ "$issues" -eq 0 ]; then
        success "Backup system health check passed"
        return 0
    else
        error "Backup system health check failed with $issues issues"
        return 1
    fi
}

cleanup_old_backups() {
    log "Cleaning up old backups (older than $MAX_AGE_DAYS days)..."
    
    local cleaned_count=0
    
    # Clean local backups
    while IFS= read -r -d '' backup; do
        rm -rf "$backup"
        log "Removed old backup: $(basename "$backup")"
        ((cleaned_count++))
    done < <(find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" -mtime +$MAX_AGE_DAYS -print0 2>/dev/null || true)
    
    # Clean external backups if available
    if [ -d "$BACKUP_BASE_DIR" ]; then
        while IFS= read -r -d '' backup; do
            rm -rf "$backup"
            log "Removed old external backup: $(basename "$backup")"
            ((cleaned_count++))
        done < <(find "$BACKUP_BASE_DIR" -maxdepth 1 -type d -name "*_*" -mtime +$MAX_AGE_DAYS -print0 2>/dev/null || true)
    fi
    
    if [ "$cleaned_count" -gt 0 ]; then
        success "Cleaned up $cleaned_count old backups"
    else
        log "No old backups to clean up"
    fi
}

verify_backup_integrity() {
    local backup_path="$1"
    
    log "Verifying backup integrity: $(basename "$backup_path")"
    
    # Check if required directories exist
    local required_dirs=("metadata")
    for dir in "${required_dirs[@]}"; do
        if [ ! -d "$backup_path/$dir" ]; then
            error "Missing directory: $dir"
            return 1
        fi
    done
    
    # Check metadata
    if [ ! -f "$backup_path/metadata/timestamp" ]; then
        error "Missing timestamp metadata"
        return 1
    fi
    
    # Verify encrypted files can be decrypted
    {% if backup_encryption.enabled %}
    if [ -f "$backup_path/security.tar.gz.gpg" ]; then
        if ! gpg --decrypt "$backup_path/security.tar.gz.gpg" >/dev/null 2>&1; then
            error "Cannot decrypt security data"
            return 1
        fi
    fi
    {% endif %}
    
    success "Backup integrity verified"
    return 0
}

show_backup_status() {
    echo -e "${BLUE}╭─────────────────────────────────────────────────────────╮${NC}"
    echo -e "${BLUE}│${NC}                 ${GREEN}BACKUP SYSTEM STATUS${NC}                   ${BLUE}│${NC}"
    echo -e "${BLUE}├─────────────────────────────────────────────────────────┤${NC}"
    
    # Local backup count
    local local_count=$(find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" 2>/dev/null | wc -l)
    printf "${BLUE}│${NC} Local backups:     %-4s                                ${BLUE}│${NC}\n" "$local_count"
    
    # Checkpoint count
    local checkpoint_count=$(find "$BACKUP_LOCAL_DIR/checkpoints" -maxdepth 1 -type d -name "*_*" 2>/dev/null | wc -l)
    printf "${BLUE}│${NC} Checkpoints:       %-4s                                ${BLUE}│${NC}\n" "$checkpoint_count"
    
    # External backup status
    if [ -d "$(dirname "$BACKUP_BASE_DIR")" ]; then
        local external_count=$(find "$BACKUP_BASE_DIR" -maxdepth 1 -type d -name "*_*" 2>/dev/null | wc -l)
        printf "${BLUE}│${NC} External backups:  %-4s (connected)                   ${BLUE}│${NC}\n" "$external_count"
    else
        printf "${BLUE}│${NC} External backups:  ${RED}----${NC} (not connected)                ${BLUE}│${NC}\n"
    fi
    
    # Latest backup
    local latest_backup=$(find "$BACKUP_LOCAL_DIR" -maxdepth 1 -type d -name "*_*" | sort -r | head -1)
    if [ -n "$latest_backup" ]; then
        local backup_date=$(date -r "$latest_backup" '+%Y-%m-%d %H:%M' 2>/dev/null || echo "Unknown")
        printf "${BLUE}│${NC} Latest backup:     %s                     ${BLUE}│${NC}\n" "$backup_date"
    else
        printf "${BLUE}│${NC} Latest backup:     ${RED}None found${NC}                            ${BLUE}│${NC}\n"
    fi
    
    # Storage usage
    if [ -d "$BACKUP_LOCAL_DIR" ]; then
        local size_kb=$(du -sk "$BACKUP_LOCAL_DIR" 2>/dev/null | cut -f1)
        local size_mb=$((size_kb / 1024))
        printf "${BLUE}│${NC} Storage used:      %d MB                              ${BLUE}│${NC}\n" "$size_mb"
    fi
    
    echo -e "${BLUE}╰─────────────────────────────────────────────────────────╯${NC}"
}

# Main execution
case "${1:-status}" in
    status)
        show_backup_status
        ;;
    health)
        check_backup_health
        ;;
    cleanup)
        cleanup_old_backups
        ;;
    verify)
        if [ -n "${2:-}" ]; then
            verify_backup_integrity "$2"
        else
            echo "Usage: backup-monitor verify BACKUP_PATH"
            exit 1
        fi
        ;;
    *)
        echo "Usage: backup-monitor {status|health|cleanup|verify}"
        echo
        echo "Commands:"
        echo "  status  - Show backup system status"
        echo "  health  - Run health checks"
        echo "  cleanup - Remove old backups"
        echo "  verify  - Verify backup integrity"
        exit 1
        ;;
esac